{"id":"node_modules/vega-lite/build/src/compile/legend/assemble.js","dependencies":[{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/legend/assemble.js.map","includedInParent":true,"mtime":499162500000},{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/package.json","includedInParent":true,"mtime":1593715260815},{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/package.json","includedInParent":true,"mtime":499162500000},{"name":"../../util","loc":{"line":3,"column":21},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/legend/assemble.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/util.js"},{"name":"./parse","loc":{"line":4,"column":22},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/legend/assemble.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/legend/parse.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"../../util\");\nvar parse_1 = require(\"./parse\");\nfunction assembleLegends(model) {\n    var legendComponentIndex = model.component.legends;\n    var legendByDomain = {};\n    for (var _i = 0, _a = util_1.keys(legendComponentIndex); _i < _a.length; _i++) {\n        var channel = _a[_i];\n        var scaleComponent = model.getScaleComponent(channel);\n        var domainHash = util_1.stringify(scaleComponent.domains);\n        if (legendByDomain[domainHash]) {\n            for (var _b = 0, _c = legendByDomain[domainHash]; _b < _c.length; _b++) {\n                var mergedLegendComponent = _c[_b];\n                var merged = parse_1.mergeLegendComponent(mergedLegendComponent, legendComponentIndex[channel]);\n                if (!merged) {\n                    // If cannot merge, need to add this legend separately\n                    legendByDomain[domainHash].push(legendComponentIndex[channel]);\n                }\n            }\n        }\n        else {\n            legendByDomain[domainHash] = [legendComponentIndex[channel].clone()];\n        }\n    }\n    return util_1.flatten(util_1.vals(legendByDomain)).map(function (legendCmpt) { return legendCmpt.combine(); });\n}\nexports.assembleLegends = assembleLegends;\n"},"sourceMaps":{"js":{"version":3,"file":"assemble.js","sourceRoot":"","sources":["../../../../src/compile/legend/assemble.ts"],"names":[],"mappings":";;AAAA,mCAA0D;AAI1D,iCAA6C;AAE7C,yBAAgC,KAAY;IAC1C,IAAM,oBAAoB,GAAG,KAAK,CAAC,SAAS,CAAC,OAAO,CAAC;IACrD,IAAM,cAAc,GAA8C,EAAE,CAAC;IAErE,KAAsB,UAA0B,EAA1B,KAAA,WAAI,CAAC,oBAAoB,CAAC,EAA1B,cAA0B,EAA1B,IAA0B,EAAE;QAA7C,IAAM,OAAO,SAAA;QAChB,IAAM,cAAc,GAAG,KAAK,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC;QACxD,IAAM,UAAU,GAAG,gBAAS,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;QACrD,IAAI,cAAc,CAAC,UAAU,CAAC,EAAE;YAC9B,KAAoC,UAA0B,EAA1B,KAAA,cAAc,CAAC,UAAU,CAAC,EAA1B,cAA0B,EAA1B,IAA0B,EAAE;gBAA3D,IAAM,qBAAqB,SAAA;gBAC9B,IAAM,MAAM,GAAG,4BAAoB,CAAC,qBAAqB,EAAE,oBAAoB,CAAC,OAAO,CAAC,CAAC,CAAC;gBAC1F,IAAI,CAAC,MAAM,EAAE;oBACX,sDAAsD;oBACtD,cAAc,CAAC,UAAU,CAAC,CAAC,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC,CAAC;iBAChE;aACF;SAEF;aAAM;YACL,cAAc,CAAC,UAAU,CAAC,GAAG,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC;SACtE;KACF;IAED,OAAO,cAAO,CAAC,WAAI,CAAC,cAAc,CAAC,CAAC,CAAC,GAAG,CAAC,UAAC,UAA2B,IAAK,OAAA,UAAU,CAAC,OAAO,EAAE,EAApB,CAAoB,CAAC,CAAC;AAClG,CAAC;AAtBD,0CAsBC","sourcesContent":["import {flatten, keys, stringify, vals} from '../../util';\nimport {VgLegend} from '../../vega.schema';\nimport {Model} from '../model';\nimport {LegendComponent} from './component';\nimport {mergeLegendComponent} from './parse';\n\nexport function assembleLegends(model: Model): VgLegend[] {\n  const legendComponentIndex = model.component.legends;\n  const legendByDomain: {[domainHash: string]: LegendComponent[]} = {};\n\n  for (const channel of keys(legendComponentIndex)) {\n    const scaleComponent = model.getScaleComponent(channel);\n    const domainHash = stringify(scaleComponent.domains);\n    if (legendByDomain[domainHash]) {\n      for (const mergedLegendComponent of legendByDomain[domainHash]) {\n        const merged = mergeLegendComponent(mergedLegendComponent, legendComponentIndex[channel]);\n        if (!merged) {\n          // If cannot merge, need to add this legend separately\n          legendByDomain[domainHash].push(legendComponentIndex[channel]);\n        }\n      }\n\n    } else {\n      legendByDomain[domainHash] = [legendComponentIndex[channel].clone()];\n    }\n  }\n\n  return flatten(vals(legendByDomain)).map((legendCmpt: LegendComponent) => legendCmpt.combine());\n}\n"]}},"error":null,"hash":"6bebc22dc24082ff1cf07290d8a8e531","cacheData":{"env":{}}}