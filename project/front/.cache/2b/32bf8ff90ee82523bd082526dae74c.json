{"id":"node_modules/vega-lite/build/src/compile/data/optimize.js","dependencies":[{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/optimize.js.map","includedInParent":true,"mtime":499162500000},{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/package.json","includedInParent":true,"mtime":1593715260815},{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/package.json","includedInParent":true,"mtime":499162500000},{"name":"tslib","loc":{"line":3,"column":22},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/optimize.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/tslib/tslib.es6.js"},{"name":"../../data","loc":{"line":4,"column":21},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/optimize.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/data.js"},{"name":"../../util","loc":{"line":5,"column":21},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/optimize.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/util.js"},{"name":"./aggregate","loc":{"line":6,"column":26},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/optimize.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/aggregate.js"},{"name":"./dataflow","loc":{"line":7,"column":25},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/optimize.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/dataflow.js"},{"name":"./facet","loc":{"line":8,"column":22},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/optimize.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/facet.js"},{"name":"./filterinvalid","loc":{"line":9,"column":30},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/optimize.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/filterinvalid.js"},{"name":"./optimizers","loc":{"line":10,"column":46},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/optimize.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/optimizers.js"},{"name":"./stack","loc":{"line":11,"column":22},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/optimize.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/stack.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar data_1 = require(\"../../data\");\nvar util_1 = require(\"../../util\");\nvar aggregate_1 = require(\"./aggregate\");\nvar dataflow_1 = require(\"./dataflow\");\nvar facet_1 = require(\"./facet\");\nvar filterinvalid_1 = require(\"./filterinvalid\");\nvar optimizers = tslib_1.__importStar(require(\"./optimizers\"));\nvar stack_1 = require(\"./stack\");\nexports.FACET_SCALE_PREFIX = 'scale_';\n/**\n * Clones the subtree and ignores output nodes except for the leafs, which are renamed.\n */\nfunction cloneSubtree(facet) {\n    function clone(node) {\n        if (!(node instanceof facet_1.FacetNode)) {\n            var copy_1 = node.clone();\n            if (copy_1 instanceof dataflow_1.OutputNode) {\n                var newName = exports.FACET_SCALE_PREFIX + copy_1.getSource();\n                copy_1.setSource(newName);\n                facet.model.component.data.outputNodes[newName] = copy_1;\n            }\n            else if (copy_1 instanceof aggregate_1.AggregateNode || copy_1 instanceof stack_1.StackNode) {\n                copy_1.addDimensions(facet.fields);\n            }\n            util_1.flatten(node.children.map(clone)).forEach(function (n) { return n.parent = copy_1; });\n            return [copy_1];\n        }\n        return util_1.flatten(node.children.map(clone));\n    }\n    return clone;\n}\n/**\n * Move facet nodes down to the next fork or output node. Also pull the main output with the facet node.\n * After moving down the facet node, make a copy of the subtree and make it a child of the main output.\n */\nfunction moveFacetDown(node) {\n    if (node instanceof facet_1.FacetNode) {\n        if (node.numChildren() === 1 && !(node.children[0] instanceof dataflow_1.OutputNode)) {\n            // move down until we hit a fork or output node\n            var child = node.children[0];\n            if (child instanceof aggregate_1.AggregateNode || child instanceof stack_1.StackNode) {\n                child.addDimensions(node.fields);\n            }\n            child.swapWithParent();\n            moveFacetDown(node);\n        }\n        else {\n            // move main to facet\n            moveMainDownToFacet(node.model.component.data.main);\n            // replicate the subtree and place it before the facet's main node\n            var copy = util_1.flatten(node.children.map(cloneSubtree(node)));\n            copy.forEach(function (c) { return c.parent = node.model.component.data.main; });\n        }\n    }\n    else {\n        node.children.forEach(moveFacetDown);\n    }\n}\nfunction moveMainDownToFacet(node) {\n    if (node instanceof dataflow_1.OutputNode && node.type === data_1.MAIN) {\n        if (node.numChildren() === 1) {\n            var child = node.children[0];\n            if (!(child instanceof facet_1.FacetNode)) {\n                child.swapWithParent();\n                moveMainDownToFacet(node);\n            }\n        }\n    }\n}\n/**\n * Remove nodes that are not required starting from a root.\n */\nfunction removeUnnecessaryNodes(node) {\n    // remove empty null filter nodes\n    if (node instanceof filterinvalid_1.FilterInvalidNode && util_1.every(util_1.vals(node.filter), function (f) { return f === null; })) {\n        node.remove();\n    }\n    // remove output nodes that are not required\n    if (node instanceof dataflow_1.OutputNode && !node.isRequired()) {\n        node.remove();\n    }\n    node.children.forEach(removeUnnecessaryNodes);\n}\n/**\n * Return all leaf nodes.\n */\nfunction getLeaves(roots) {\n    var leaves = [];\n    function append(node) {\n        if (node.numChildren() === 0) {\n            leaves.push(node);\n        }\n        else {\n            node.children.forEach(append);\n        }\n    }\n    roots.forEach(append);\n    return leaves;\n}\n/**\n * Optimizes the dataflow of the passed in data component.\n */\nfunction optimizeDataflow(dataComponent) {\n    var roots = util_1.vals(dataComponent.sources);\n    roots.forEach(removeUnnecessaryNodes);\n    // remove source nodes that don't have any children because they also don't have output nodes\n    roots = roots.filter(function (r) { return r.numChildren() > 0; });\n    getLeaves(roots).forEach(optimizers.iterateFromLeaves(optimizers.removeUnusedSubtrees));\n    roots = roots.filter(function (r) { return r.numChildren() > 0; });\n    getLeaves(roots).forEach(optimizers.iterateFromLeaves(optimizers.moveParseUp));\n    getLeaves(roots).forEach(optimizers.removeDuplicateTimeUnits);\n    roots.forEach(moveFacetDown);\n    util_1.keys(dataComponent.sources).forEach(function (s) {\n        if (dataComponent.sources[s].numChildren() === 0) {\n            delete dataComponent.sources[s];\n        }\n    });\n}\nexports.optimizeDataflow = optimizeDataflow;\n"},"sourceMaps":{"js":{"version":3,"file":"optimize.js","sourceRoot":"","sources":["../../../../src/compile/data/optimize.ts"],"names":[],"mappings":"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","sourcesContent":["import {MAIN} from '../../data';\nimport {every, flatten, keys, vals} from '../../util';\nimport {AggregateNode} from './aggregate';\nimport {DataFlowNode, OutputNode} from './dataflow';\nimport {FacetNode} from './facet';\nimport {FilterInvalidNode} from './filterinvalid';\nimport {DataComponent} from './index';\nimport * as optimizers from './optimizers';\nimport {SourceNode} from './source';\nimport {StackNode} from './stack';\n\nexport const FACET_SCALE_PREFIX = 'scale_';\n\n/**\n * Clones the subtree and ignores output nodes except for the leafs, which are renamed.\n */\nfunction cloneSubtree(facet: FacetNode) {\n  function clone(node: DataFlowNode): DataFlowNode[] {\n    if (!(node instanceof FacetNode)) {\n      const copy = node.clone();\n\n      if (copy instanceof OutputNode) {\n        const newName = FACET_SCALE_PREFIX + copy.getSource();\n        copy.setSource(newName);\n\n        facet.model.component.data.outputNodes[newName] = copy;\n      } else if (copy instanceof AggregateNode || copy instanceof StackNode) {\n        copy.addDimensions(facet.fields);\n      }\n      flatten(node.children.map(clone)).forEach((n: DataFlowNode) => n.parent = copy);\n\n      return [copy];\n    }\n\n    return flatten(node.children.map(clone));\n  }\n  return clone;\n}\n\n/**\n * Move facet nodes down to the next fork or output node. Also pull the main output with the facet node.\n * After moving down the facet node, make a copy of the subtree and make it a child of the main output.\n */\nfunction moveFacetDown(node: DataFlowNode) {\n  if (node instanceof FacetNode) {\n    if (node.numChildren() === 1 && !(node.children[0] instanceof OutputNode)) {\n      // move down until we hit a fork or output node\n\n      const child = node.children[0];\n\n      if (child instanceof AggregateNode || child instanceof StackNode) {\n        child.addDimensions(node.fields);\n      }\n\n      child.swapWithParent();\n      moveFacetDown(node);\n    } else {\n      // move main to facet\n      moveMainDownToFacet(node.model.component.data.main);\n\n      // replicate the subtree and place it before the facet's main node\n      const copy: DataFlowNode[] = flatten(node.children.map(cloneSubtree(node)));\n      copy.forEach(c => c.parent = node.model.component.data.main);\n    }\n  } else {\n    node.children.forEach(moveFacetDown);\n  }\n}\n\nfunction moveMainDownToFacet(node: DataFlowNode) {\n  if (node instanceof OutputNode && node.type === MAIN) {\n    if (node.numChildren() === 1) {\n      const child = node.children[0];\n\n      if (!(child instanceof FacetNode)) {\n        child.swapWithParent();\n        moveMainDownToFacet(node);\n      }\n    }\n  }\n}\n\n/**\n * Remove nodes that are not required starting from a root.\n */\nfunction removeUnnecessaryNodes(node: DataFlowNode) {\n\n  // remove empty null filter nodes\n  if (node instanceof FilterInvalidNode && every(vals(node.filter), f => f === null)) {\n    node.remove();\n  }\n\n  // remove output nodes that are not required\n  if (node instanceof OutputNode && !node.isRequired()) {\n    node.remove();\n  }\n\n  node.children.forEach(removeUnnecessaryNodes);\n}\n\n/**\n * Return all leaf nodes.\n */\nfunction getLeaves(roots: DataFlowNode[]) {\n  const leaves: DataFlowNode[] = [];\n  function append(node: DataFlowNode) {\n    if (node.numChildren() === 0) {\n      leaves.push(node);\n    } else {\n      node.children.forEach(append);\n    }\n  }\n\n  roots.forEach(append);\n  return leaves;\n}\n\n/**\n * Optimizes the dataflow of the passed in data component.\n */\nexport function optimizeDataflow(dataComponent: DataComponent) {\n  let roots: SourceNode[] = vals(dataComponent.sources);\n\n  roots.forEach(removeUnnecessaryNodes);\n\n  // remove source nodes that don't have any children because they also don't have output nodes\n  roots = roots.filter(r => r.numChildren() > 0);\n  getLeaves(roots).forEach(optimizers.iterateFromLeaves(optimizers.removeUnusedSubtrees));\n  roots = roots.filter(r => r.numChildren() > 0);\n\n  getLeaves(roots).forEach(optimizers.iterateFromLeaves(optimizers.moveParseUp));\n  getLeaves(roots).forEach(optimizers.removeDuplicateTimeUnits);\n\n  roots.forEach(moveFacetDown);\n\n  keys(dataComponent.sources).forEach(s => {\n    if (dataComponent.sources[s].numChildren() === 0) {\n      delete dataComponent.sources[s];\n    }\n  });\n}\n"]}},"error":null,"hash":"0cb6a117fdbe923f4d0fa0687c83767c","cacheData":{"env":{}}}