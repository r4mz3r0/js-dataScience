{"id":"node_modules/vega-lite/build/src/compile/legend/encode.js","dependencies":[{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/legend/encode.js.map","includedInParent":true,"mtime":499162500000},{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/package.json","includedInParent":true,"mtime":1593715260815},{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/package.json","includedInParent":true,"mtime":499162500000},{"name":"tslib","loc":{"line":3,"column":22},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/legend/encode.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/tslib/tslib.es6.js"},{"name":"vega-util","loc":{"line":4,"column":26},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/legend/encode.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-util/index.js"},{"name":"../../channel","loc":{"line":5,"column":24},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/legend/encode.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/channel.js"},{"name":"../../fielddef","loc":{"line":6,"column":25},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/legend/encode.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/fielddef.js"},{"name":"../../mark","loc":{"line":7,"column":21},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/legend/encode.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/mark.js"},{"name":"../../scale","loc":{"line":8,"column":22},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/legend/encode.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/scale.js"},{"name":"../../util","loc":{"line":9,"column":21},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/legend/encode.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/util.js"},{"name":"../common","loc":{"line":10,"column":23},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/legend/encode.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/common.js"},{"name":"../mark/mixins","loc":{"line":11,"column":42},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/legend/encode.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/mixins.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar vega_util_1 = require(\"vega-util\");\nvar channel_1 = require(\"../../channel\");\nvar fielddef_1 = require(\"../../fielddef\");\nvar mark_1 = require(\"../../mark\");\nvar scale_1 = require(\"../../scale\");\nvar util_1 = require(\"../../util\");\nvar common_1 = require(\"../common\");\nvar mixins = tslib_1.__importStar(require(\"../mark/mixins\"));\nfunction symbols(fieldDef, symbolsSpec, model, channel, type) {\n    if (type === 'gradient') {\n        return undefined;\n    }\n    var out = tslib_1.__assign({}, common_1.applyMarkConfig({}, model, mark_1.FILL_STROKE_CONFIG), mixins.color(model));\n    switch (model.mark) {\n        case mark_1.BAR:\n        case mark_1.TICK:\n        case mark_1.TEXT:\n            out.shape = { value: 'square' };\n            break;\n        case mark_1.CIRCLE:\n        case mark_1.SQUARE:\n            out.shape = { value: model.mark };\n            break;\n        case mark_1.POINT:\n        case mark_1.LINE:\n        case mark_1.GEOSHAPE:\n        case mark_1.AREA:\n            // use default circle\n            break;\n    }\n    var markDef = model.markDef, encoding = model.encoding;\n    var filled = markDef.filled;\n    if (out.fill) {\n        // for fill legend, we don't want any fill in symbol\n        if (channel === 'fill' || (filled && channel === channel_1.COLOR)) {\n            delete out.fill;\n        }\n        else {\n            if (out.fill['field']) {\n                // For others, remove fill field\n                delete out.fill;\n            }\n            else if (vega_util_1.isArray(out.fill)) {\n                var fill = getFirstConditionValue(encoding.fill || encoding.color) || markDef.fill || (filled && markDef.color);\n                if (fill) {\n                    out.fill = { value: fill };\n                }\n            }\n        }\n    }\n    if (out.stroke) {\n        if (channel === 'stroke' || (!filled && channel === channel_1.COLOR)) {\n            delete out.stroke;\n        }\n        else {\n            if (out.stroke['field']) {\n                // For others, remove stroke field\n                delete out.stroke;\n            }\n            else if (vega_util_1.isArray(out.stroke)) {\n                var stroke = getFirstConditionValue(encoding.stroke || encoding.color) || markDef.stroke || (!filled && markDef.color);\n                if (stroke) {\n                    out.stroke = { value: stroke };\n                }\n            }\n        }\n    }\n    if (out.fill && out.fill['value'] !== 'transparent' && !out.stroke) {\n        // for non color channel's legend, we need to override symbol stroke config from Vega config\n        out.stroke = { value: 'transparent' };\n    }\n    if (channel !== channel_1.SHAPE) {\n        var shape = getFirstConditionValue(encoding.shape) || markDef.shape;\n        if (shape) {\n            out.shape = { value: shape };\n        }\n    }\n    if (channel !== channel_1.OPACITY) {\n        var opacity = getMaxValue(encoding.opacity) || markDef.opacity;\n        if (opacity) { // only apply opacity if it is neither zero or undefined\n            out.opacity = { value: opacity };\n        }\n    }\n    out = tslib_1.__assign({}, out, symbolsSpec);\n    return util_1.keys(out).length > 0 ? out : undefined;\n}\nexports.symbols = symbols;\nfunction gradient(fieldDef, gradientSpec, model, channel, type) {\n    var out = {};\n    if (type === 'gradient') {\n        var opacity = getMaxValue(model.encoding.opacity) || model.markDef.opacity;\n        if (opacity) { // only apply opacity if it is neither zero or undefined\n            out.opacity = { value: opacity };\n        }\n    }\n    out = tslib_1.__assign({}, out, gradientSpec);\n    return util_1.keys(out).length > 0 ? out : undefined;\n}\nexports.gradient = gradient;\nfunction labels(fieldDef, labelsSpec, model, channel, type) {\n    var legend = model.legend(channel);\n    var config = model.config;\n    var out = {};\n    if (fielddef_1.isTimeFieldDef(fieldDef)) {\n        var isUTCScale = model.getScaleComponent(channel).get('type') === scale_1.ScaleType.UTC;\n        var expr = common_1.timeFormatExpression('datum.value', fieldDef.timeUnit, legend.format, config.legend.shortTimeLabels, config.timeFormat, isUTCScale);\n        labelsSpec = tslib_1.__assign({}, (expr ? { text: { signal: expr } } : {}), labelsSpec);\n    }\n    out = tslib_1.__assign({}, out, labelsSpec);\n    return util_1.keys(out).length > 0 ? out : undefined;\n}\nexports.labels = labels;\nfunction getMaxValue(channelDef) {\n    return getConditionValue(channelDef, function (v, conditionalDef) { return Math.max(v, conditionalDef.value); });\n}\nfunction getFirstConditionValue(channelDef) {\n    return getConditionValue(channelDef, function (v, conditionalDef) { return v !== undefined ? v : conditionalDef.value; });\n}\nfunction getConditionValue(channelDef, reducer) {\n    if (fielddef_1.hasConditionalValueDef(channelDef)) {\n        return (vega_util_1.isArray(channelDef.condition) ? channelDef.condition : [channelDef.condition])\n            .reduce(reducer, channelDef.value);\n    }\n    else if (fielddef_1.isValueDef(channelDef)) {\n        return channelDef.value;\n    }\n    return undefined;\n}\n"},"sourceMaps":{"js":{"version":3,"file":"encode.js","sourceRoot":"","sources":["../../../../src/compile/legend/encode.ts"],"names":[],"mappings":"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","sourcesContent":["import {isArray} from 'vega-util';\n\nimport {Channel, COLOR, NonPositionScaleChannel, OPACITY, SHAPE} from '../../channel';\nimport {\n  Conditional,\n  FieldDef,\n  FieldDefWithCondition,\n  hasConditionalValueDef,\n  isTimeFieldDef,\n  isValueDef,\n  MarkPropFieldDef,\n  ValueDef,\n  ValueDefWithCondition,\n} from '../../fielddef';\nimport {AREA, BAR, CIRCLE, FILL_STROKE_CONFIG, GEOSHAPE, LINE, POINT, SQUARE, TEXT, TICK} from '../../mark';\nimport {ScaleType} from '../../scale';\nimport {keys} from '../../util';\nimport {LegendType, VgEncodeEntry} from '../../vega.schema';\nimport {applyMarkConfig, timeFormatExpression} from '../common';\nimport * as mixins from '../mark/mixins';\nimport {UnitModel} from '../unit';\n\nexport function symbols(fieldDef: FieldDef<string>, symbolsSpec: any, model: UnitModel, channel: Channel, type: LegendType): VgEncodeEntry {\n  if (type === 'gradient') {\n    return undefined;\n  }\n\n  let out = {\n    ...applyMarkConfig({}, model, FILL_STROKE_CONFIG),\n    ...mixins.color(model)\n  };\n\n  switch (model.mark) {\n    case BAR:\n    case TICK:\n    case TEXT:\n      out.shape = {value: 'square'};\n      break;\n    case CIRCLE:\n    case SQUARE:\n      out.shape = {value: model.mark};\n      break;\n    case POINT:\n    case LINE:\n    case GEOSHAPE:\n    case AREA:\n      // use default circle\n      break;\n  }\n\n  const {markDef, encoding} = model;\n  const filled = markDef.filled;\n\n  if (out.fill) {\n    // for fill legend, we don't want any fill in symbol\n    if (channel === 'fill' || (filled && channel === COLOR)) {\n      delete out.fill;\n    } else {\n      if (out.fill['field']) {\n        // For others, remove fill field\n        delete out.fill;\n      } else if (isArray(out.fill)) {\n        const fill = getFirstConditionValue(encoding.fill || encoding.color) || markDef.fill || (filled && markDef.color);\n        if (fill) {\n          out.fill = {value: fill};\n        }\n      }\n    }\n  }\n\n  if (out.stroke) {\n    if (channel === 'stroke' || (!filled && channel === COLOR)) {\n      delete out.stroke;\n    } else {\n      if (out.stroke['field']) {\n        // For others, remove stroke field\n        delete out.stroke;\n      } else if (isArray(out.stroke)) {\n        const stroke = getFirstConditionValue(encoding.stroke || encoding.color) || markDef.stroke || (!filled && markDef.color);\n        if (stroke) {\n          out.stroke = {value: stroke};\n        }\n      }\n    }\n  }\n\n  if (out.fill && out.fill['value'] !== 'transparent' && !out.stroke) {\n    // for non color channel's legend, we need to override symbol stroke config from Vega config\n    out.stroke = {value: 'transparent'};\n  }\n\n  if (channel !== SHAPE) {\n    const shape = getFirstConditionValue(encoding.shape) || markDef.shape;\n    if (shape) {\n      out.shape = {value: shape};\n    }\n  }\n\n  if (channel !== OPACITY) {\n    const opacity = getMaxValue(encoding.opacity) || markDef.opacity;\n    if (opacity) { // only apply opacity if it is neither zero or undefined\n      out.opacity = {value: opacity};\n    }\n  }\n\n  out = {...out, ...symbolsSpec};\n\n  return keys(out).length > 0 ? out : undefined;\n}\n\nexport function gradient(fieldDef: FieldDef<string>, gradientSpec: any, model: UnitModel, channel: Channel, type: LegendType) {\n  let out: any = {};\n\n  if (type === 'gradient') {\n    const opacity = getMaxValue(model.encoding.opacity) || model.markDef.opacity;\n    if (opacity) { // only apply opacity if it is neither zero or undefined\n      out.opacity = {value: opacity};\n    }\n  }\n\n  out = {...out, ...gradientSpec};\n  return keys(out).length > 0 ? out : undefined;\n}\n\nexport function labels(fieldDef: FieldDef<string>, labelsSpec: any, model: UnitModel, channel: NonPositionScaleChannel, type: LegendType) {\n  const legend = model.legend(channel);\n  const config = model.config;\n\n  let out: any = {};\n\n  if (isTimeFieldDef(fieldDef)) {\n    const isUTCScale = model.getScaleComponent(channel).get('type') === ScaleType.UTC;\n    const expr = timeFormatExpression('datum.value', fieldDef.timeUnit, legend.format, config.legend.shortTimeLabels, config.timeFormat, isUTCScale);\n    labelsSpec = {\n      ...(expr ? {text: {signal: expr}} : {}),\n      ...labelsSpec,\n    };\n  }\n\n  out = {...out, ...labelsSpec};\n\n  return keys(out).length > 0 ? out : undefined;\n}\n\nfunction getMaxValue(channelDef: FieldDefWithCondition<MarkPropFieldDef<string>> | ValueDefWithCondition<MarkPropFieldDef<string>>) {\n  return getConditionValue(channelDef,\n    (v: number, conditionalDef) => Math.max(v, conditionalDef.value as any)\n  );\n}\n\nfunction getFirstConditionValue(channelDef: FieldDefWithCondition<MarkPropFieldDef<string>> | ValueDefWithCondition<MarkPropFieldDef<string>>) {\n  return getConditionValue(channelDef,\n    (v: number, conditionalDef) => v !== undefined ? v : conditionalDef.value\n  );\n}\n\nfunction getConditionValue<T>(\n  channelDef: FieldDefWithCondition<MarkPropFieldDef<string>> | ValueDefWithCondition<MarkPropFieldDef<string>>,\n  reducer: (val: T, conditionalDef: Conditional<ValueDef>) => T\n): T {\n\n  if (hasConditionalValueDef(channelDef)) {\n    return (isArray(channelDef.condition) ? channelDef.condition : [channelDef.condition])\n      .reduce(reducer, channelDef.value as any);\n  } else if (isValueDef(channelDef)) {\n    return channelDef.value as any;\n  }\n  return undefined;\n}\n"]}},"error":null,"hash":"d1bc224bcfad51e29f6c44acb6e9acb4","cacheData":{"env":{}}}