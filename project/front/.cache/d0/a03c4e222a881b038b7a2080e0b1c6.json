{"id":"node_modules/vega-lite/build/src/compile/scale/parse.js","dependencies":[{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/scale/parse.js.map","includedInParent":true,"mtime":499162500000},{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/package.json","includedInParent":true,"mtime":1593715260815},{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/package.json","includedInParent":true,"mtime":499162500000},{"name":"../../channel","loc":{"line":3,"column":24},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/scale/parse.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/channel.js"},{"name":"../../fielddef","loc":{"line":4,"column":25},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/scale/parse.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/fielddef.js"},{"name":"../../mark","loc":{"line":5,"column":21},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/scale/parse.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/mark.js"},{"name":"../../scale","loc":{"line":6,"column":22},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/scale/parse.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/scale.js"},{"name":"../../type","loc":{"line":7,"column":21},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/scale/parse.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/type.js"},{"name":"../../util","loc":{"line":8,"column":21},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/scale/parse.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/util.js"},{"name":"../model","loc":{"line":9,"column":22},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/scale/parse.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/model.js"},{"name":"../resolve","loc":{"line":10,"column":24},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/scale/parse.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/resolve.js"},{"name":"../split","loc":{"line":11,"column":22},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/scale/parse.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/split.js"},{"name":"./component","loc":{"line":12,"column":26},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/scale/parse.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/scale/component.js"},{"name":"./domain","loc":{"line":13,"column":23},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/scale/parse.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/scale/domain.js"},{"name":"./properties","loc":{"line":14,"column":27},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/scale/parse.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/scale/properties.js"},{"name":"./range","loc":{"line":15,"column":22},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/scale/parse.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/scale/range.js"},{"name":"./type","loc":{"line":16,"column":21},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/scale/parse.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/scale/type.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar channel_1 = require(\"../../channel\");\nvar fielddef_1 = require(\"../../fielddef\");\nvar mark_1 = require(\"../../mark\");\nvar scale_1 = require(\"../../scale\");\nvar type_1 = require(\"../../type\");\nvar util_1 = require(\"../../util\");\nvar model_1 = require(\"../model\");\nvar resolve_1 = require(\"../resolve\");\nvar split_1 = require(\"../split\");\nvar component_1 = require(\"./component\");\nvar domain_1 = require(\"./domain\");\nvar properties_1 = require(\"./properties\");\nvar range_1 = require(\"./range\");\nvar type_2 = require(\"./type\");\nfunction parseScale(model) {\n    parseScaleCore(model);\n    domain_1.parseScaleDomain(model);\n    for (var _i = 0, NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES_1 = scale_1.NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES; _i < NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES_1.length; _i++) {\n        var prop = NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES_1[_i];\n        properties_1.parseScaleProperty(model, prop);\n    }\n    // range depends on zero\n    range_1.parseScaleRange(model);\n}\nexports.parseScale = parseScale;\nfunction parseScaleCore(model) {\n    if (model_1.isUnitModel(model)) {\n        model.component.scales = parseUnitScaleCore(model);\n    }\n    else {\n        model.component.scales = parseNonUnitScaleCore(model);\n    }\n}\nexports.parseScaleCore = parseScaleCore;\n/**\n * Parse scales for all channels of a model.\n */\nfunction parseUnitScaleCore(model) {\n    var encoding = model.encoding, config = model.config, mark = model.mark;\n    return channel_1.SCALE_CHANNELS.reduce(function (scaleComponents, channel) {\n        var fieldDef;\n        var specifiedScale = undefined;\n        var channelDef = encoding[channel];\n        // Don't generate scale for shape of geoshape\n        if (fielddef_1.isFieldDef(channelDef) && mark === mark_1.GEOSHAPE &&\n            channel === channel_1.SHAPE && channelDef.type === type_1.GEOJSON) {\n            return scaleComponents;\n        }\n        if (fielddef_1.isFieldDef(channelDef)) {\n            fieldDef = channelDef;\n            specifiedScale = channelDef.scale;\n        }\n        else if (fielddef_1.hasConditionalFieldDef(channelDef)) {\n            fieldDef = channelDef.condition;\n            specifiedScale = channelDef.condition['scale']; // We use ['scale'] since we know that channel here has scale for sure\n        }\n        else if (channel === channel_1.X) {\n            fieldDef = fielddef_1.getFieldDef(encoding.x2);\n        }\n        else if (channel === channel_1.Y) {\n            fieldDef = fielddef_1.getFieldDef(encoding.y2);\n        }\n        if (fieldDef && specifiedScale !== null && specifiedScale !== false) {\n            specifiedScale = specifiedScale || {};\n            var specifiedScaleType = specifiedScale.type;\n            var sType = type_2.scaleType(specifiedScale.type, channel, fieldDef, mark, config.scale);\n            scaleComponents[channel] = new component_1.ScaleComponent(model.scaleName(channel + '', true), { value: sType, explicit: specifiedScaleType === sType });\n        }\n        return scaleComponents;\n    }, {});\n}\nvar scaleTypeTieBreaker = split_1.tieBreakByComparing(function (st1, st2) { return (scale_1.scaleTypePrecedence(st1) - scale_1.scaleTypePrecedence(st2)); });\nfunction parseNonUnitScaleCore(model) {\n    var scaleComponents = model.component.scales = {};\n    var scaleTypeWithExplicitIndex = {};\n    var resolve = model.component.resolve;\n    var _loop_1 = function (child) {\n        parseScaleCore(child);\n        // Instead of always merging right away -- check if it is compatible to merge first!\n        util_1.keys(child.component.scales).forEach(function (channel) {\n            // if resolve is undefined, set default first\n            resolve.scale[channel] = resolve.scale[channel] || resolve_1.defaultScaleResolve(channel, model);\n            if (resolve.scale[channel] === 'shared') {\n                var explicitScaleType = scaleTypeWithExplicitIndex[channel];\n                var childScaleType = child.component.scales[channel].getWithExplicit('type');\n                if (explicitScaleType) {\n                    if (scale_1.scaleCompatible(explicitScaleType.value, childScaleType.value)) {\n                        // merge scale component if type are compatible\n                        scaleTypeWithExplicitIndex[channel] = split_1.mergeValuesWithExplicit(explicitScaleType, childScaleType, 'type', 'scale', scaleTypeTieBreaker);\n                    }\n                    else {\n                        // Otherwise, update conflicting channel to be independent\n                        resolve.scale[channel] = 'independent';\n                        // Remove from the index so they don't get merged\n                        delete scaleTypeWithExplicitIndex[channel];\n                    }\n                }\n                else {\n                    scaleTypeWithExplicitIndex[channel] = childScaleType;\n                }\n            }\n        });\n    };\n    // Parse each child scale and determine if a particular channel can be merged.\n    for (var _i = 0, _a = model.children; _i < _a.length; _i++) {\n        var child = _a[_i];\n        _loop_1(child);\n    }\n    // Merge each channel listed in the index\n    util_1.keys(scaleTypeWithExplicitIndex).forEach(function (channel) {\n        // Create new merged scale component\n        var name = model.scaleName(channel, true);\n        var typeWithExplicit = scaleTypeWithExplicitIndex[channel];\n        scaleComponents[channel] = new component_1.ScaleComponent(name, typeWithExplicit);\n        // rename each child and mark them as merged\n        for (var _i = 0, _a = model.children; _i < _a.length; _i++) {\n            var child = _a[_i];\n            var childScale = child.component.scales[channel];\n            if (childScale) {\n                child.renameScale(childScale.get('name'), name);\n                childScale.merged = true;\n            }\n        }\n    });\n    return scaleComponents;\n}\n"},"sourceMaps":{"js":{"version":3,"file":"parse.js","sourceRoot":"","sources":["../../../../src/compile/scale/parse.ts"],"names":[],"mappings":"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","sourcesContent":["import {SCALE_CHANNELS, ScaleChannel, SHAPE, X, Y} from '../../channel';\nimport {FieldDef, getFieldDef, hasConditionalFieldDef, isFieldDef} from '../../fielddef';\nimport {GEOSHAPE} from '../../mark';\nimport {\n  NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES,\n  Scale,\n  scaleCompatible,\n  ScaleType,\n  scaleTypePrecedence,\n} from '../../scale';\nimport {GEOJSON} from '../../type';\nimport {keys} from '../../util';\nimport {VgScale} from '../../vega.schema';\nimport {isUnitModel, Model} from '../model';\nimport {defaultScaleResolve} from '../resolve';\nimport {Explicit, mergeValuesWithExplicit, tieBreakByComparing} from '../split';\nimport {UnitModel} from '../unit';\nimport {ScaleComponent, ScaleComponentIndex} from './component';\nimport {parseScaleDomain} from './domain';\nimport {parseScaleProperty} from './properties';\nimport {parseScaleRange} from './range';\nimport {scaleType} from './type';\n\nexport function parseScale(model: Model) {\n  parseScaleCore(model);\n  parseScaleDomain(model);\n  for (const prop of NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES) {\n    parseScaleProperty(model, prop);\n  }\n  // range depends on zero\n  parseScaleRange(model);\n}\n\nexport function parseScaleCore(model: Model) {\n  if (isUnitModel(model)) {\n    model.component.scales = parseUnitScaleCore(model);\n  } else {\n    model.component.scales = parseNonUnitScaleCore(model);\n  }\n}\n\n/**\n * Parse scales for all channels of a model.\n */\nfunction parseUnitScaleCore(model: UnitModel): ScaleComponentIndex {\n  const {encoding, config, mark} = model;\n\n  return SCALE_CHANNELS.reduce((scaleComponents: ScaleComponentIndex, channel: ScaleChannel) => {\n    let fieldDef: FieldDef<string>;\n    let specifiedScale: Scale | null = undefined;\n\n    const channelDef = encoding[channel];\n\n    // Don't generate scale for shape of geoshape\n    if (\n      isFieldDef(channelDef) && mark === GEOSHAPE &&\n      channel === SHAPE && channelDef.type === GEOJSON\n    ) {\n      return scaleComponents;\n    }\n\n    if (isFieldDef(channelDef)) {\n      fieldDef = channelDef;\n      specifiedScale = channelDef.scale;\n    } else if (hasConditionalFieldDef(channelDef)) {\n      fieldDef = channelDef.condition;\n      specifiedScale = channelDef.condition['scale']; // We use ['scale'] since we know that channel here has scale for sure\n    } else if (channel === X) {\n      fieldDef = getFieldDef(encoding.x2);\n    } else if (channel === Y) {\n      fieldDef = getFieldDef(encoding.y2);\n    }\n\n    if (fieldDef && specifiedScale !== null && specifiedScale !== false) {\n      specifiedScale = specifiedScale || {};\n      const specifiedScaleType = specifiedScale.type;\n      const sType = scaleType(specifiedScale.type, channel, fieldDef, mark, config.scale);\n      scaleComponents[channel] = new ScaleComponent(\n        model.scaleName(channel + '', true),\n        {value: sType, explicit: specifiedScaleType === sType}\n      );\n    }\n    return scaleComponents;\n  }, {});\n}\n\nconst scaleTypeTieBreaker = tieBreakByComparing(\n  (st1: ScaleType, st2: ScaleType) => (scaleTypePrecedence(st1) - scaleTypePrecedence(st2))\n);\n\n\nfunction parseNonUnitScaleCore(model: Model) {\n  const scaleComponents: ScaleComponentIndex = model.component.scales = {};\n\n  const scaleTypeWithExplicitIndex: {\n    // Using Mapped Type to declare type (https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types)\n    [k in ScaleChannel]?: Explicit<ScaleType>\n  } = {};\n  const resolve = model.component.resolve;\n\n  // Parse each child scale and determine if a particular channel can be merged.\n  for (const child of model.children) {\n    parseScaleCore(child);\n\n    // Instead of always merging right away -- check if it is compatible to merge first!\n    keys(child.component.scales).forEach((channel: ScaleChannel) => {\n      // if resolve is undefined, set default first\n      resolve.scale[channel] = resolve.scale[channel] || defaultScaleResolve(channel, model);\n\n      if (resolve.scale[channel] === 'shared') {\n        const explicitScaleType = scaleTypeWithExplicitIndex[channel];\n        const childScaleType = child.component.scales[channel].getWithExplicit('type');\n\n        if (explicitScaleType) {\n          if (scaleCompatible(explicitScaleType.value, childScaleType.value)) {\n            // merge scale component if type are compatible\n            scaleTypeWithExplicitIndex[channel] = mergeValuesWithExplicit<VgScale, ScaleType>(\n              explicitScaleType, childScaleType, 'type', 'scale', scaleTypeTieBreaker\n            );\n          } else {\n            // Otherwise, update conflicting channel to be independent\n            resolve.scale[channel] = 'independent';\n            // Remove from the index so they don't get merged\n            delete scaleTypeWithExplicitIndex[channel];\n          }\n        } else {\n          scaleTypeWithExplicitIndex[channel] = childScaleType;\n        }\n      }\n    });\n  }\n\n  // Merge each channel listed in the index\n  keys(scaleTypeWithExplicitIndex).forEach((channel: ScaleChannel) => {\n    // Create new merged scale component\n    const name = model.scaleName(channel, true);\n    const typeWithExplicit = scaleTypeWithExplicitIndex[channel];\n    scaleComponents[channel] = new ScaleComponent(name, typeWithExplicit);\n\n    // rename each child and mark them as merged\n    for (const child of model.children) {\n      const childScale = child.component.scales[channel];\n      if (childScale) {\n        child.renameScale(childScale.get('name'), name);\n        childScale.merged = true;\n      }\n    }\n  });\n\n  return scaleComponents;\n}\n"]}},"error":null,"hash":"c56f659f0cee47efc60c095394b1021f","cacheData":{"env":{}}}