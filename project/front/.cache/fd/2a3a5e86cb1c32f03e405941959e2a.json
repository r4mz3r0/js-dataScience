{"id":"node_modules/vega-lite/build/src/compile/data/formatparse.js","dependencies":[{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/formatparse.js.map","includedInParent":true,"mtime":499162500000},{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/package.json","includedInParent":true,"mtime":1593715260815},{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/package.json","includedInParent":true,"mtime":499162500000},{"name":"tslib","loc":{"line":3,"column":22},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/formatparse.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/tslib/tslib.es6.js"},{"name":"vega-util","loc":{"line":4,"column":26},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/formatparse.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-util/index.js"},{"name":"../../aggregate","loc":{"line":5,"column":26},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/formatparse.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/aggregate.js"},{"name":"../../datetime","loc":{"line":6,"column":25},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/formatparse.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/datetime.js"},{"name":"../../fielddef","loc":{"line":7,"column":25},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/formatparse.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/fielddef.js"},{"name":"../../log","loc":{"line":8,"column":39},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/formatparse.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/log.js"},{"name":"../../logical","loc":{"line":9,"column":24},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/formatparse.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/logical.js"},{"name":"../../predicate","loc":{"line":10,"column":26},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/formatparse.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/predicate.js"},{"name":"../../sort","loc":{"line":11,"column":21},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/formatparse.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/sort.js"},{"name":"../../util","loc":{"line":12,"column":21},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/formatparse.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/util.js"},{"name":"../model","loc":{"line":13,"column":22},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/formatparse.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/model.js"},{"name":"../split","loc":{"line":14,"column":22},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/formatparse.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/split.js"},{"name":"./dataflow","loc":{"line":15,"column":25},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/formatparse.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/dataflow.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar vega_util_1 = require(\"vega-util\");\nvar aggregate_1 = require(\"../../aggregate\");\nvar datetime_1 = require(\"../../datetime\");\nvar fielddef_1 = require(\"../../fielddef\");\nvar log = tslib_1.__importStar(require(\"../../log\"));\nvar logical_1 = require(\"../../logical\");\nvar predicate_1 = require(\"../../predicate\");\nvar sort_1 = require(\"../../sort\");\nvar util_1 = require(\"../../util\");\nvar model_1 = require(\"../model\");\nvar split_1 = require(\"../split\");\nvar dataflow_1 = require(\"./dataflow\");\n/**\n * @param field The field.\n * @param parse What to parse the field as.\n */\nfunction parseExpression(field, parse) {\n    var f = util_1.accessPathWithDatum(field);\n    if (parse === 'number') {\n        return \"toNumber(\" + f + \")\";\n    }\n    else if (parse === 'boolean') {\n        return \"toBoolean(\" + f + \")\";\n    }\n    else if (parse === 'string') {\n        return \"toString(\" + f + \")\";\n    }\n    else if (parse === 'date') {\n        return \"toDate(\" + f + \")\";\n    }\n    else if (parse === 'flatten') {\n        return f;\n    }\n    else if (parse.indexOf('date:') === 0) {\n        var specifier = parse.slice(5, parse.length);\n        return \"timeParse(\" + f + \",\" + specifier + \")\";\n    }\n    else if (parse.indexOf('utc:') === 0) {\n        var specifier = parse.slice(4, parse.length);\n        return \"utcParse(\" + f + \",\" + specifier + \")\";\n    }\n    else {\n        log.warn(log.message.unrecognizedParse(parse));\n        return null;\n    }\n}\nvar ParseNode = /** @class */ (function (_super) {\n    tslib_1.__extends(ParseNode, _super);\n    function ParseNode(parent, parse) {\n        var _this = _super.call(this, parent) || this;\n        _this._parse = parse;\n        return _this;\n    }\n    ParseNode.prototype.clone = function () {\n        return new ParseNode(null, util_1.duplicate(this._parse));\n    };\n    /**\n     * Creates a parse node from a data.format.parse and updates ancestorParse.\n     */\n    ParseNode.makeExplicit = function (parent, model, ancestorParse) {\n        // Custom parse\n        var explicit = {};\n        var data = model.data;\n        if (data && data.format && data.format.parse) {\n            explicit = data.format.parse;\n        }\n        return this.makeWithAncestors(parent, explicit, {}, ancestorParse);\n    };\n    ParseNode.makeImplicitFromFilterTransform = function (parent, transform, ancestorParse) {\n        var parse = {};\n        logical_1.forEachLeaf(transform.filter, function (filter) {\n            if (predicate_1.isFieldPredicate(filter)) {\n                // Automatically add a parse node for filters with filter objects\n                var val = null;\n                // For EqualFilter, just use the equal property.\n                // For RangeFilter and OneOfFilter, all array members should have\n                // the same type, so we only use the first one.\n                if (predicate_1.isFieldEqualPredicate(filter)) {\n                    val = filter.equal;\n                }\n                else if (predicate_1.isFieldRangePredicate(filter)) {\n                    val = filter.range[0];\n                }\n                else if (predicate_1.isFieldOneOfPredicate(filter)) {\n                    val = (filter.oneOf || filter['in'])[0];\n                } // else -- for filter expression, we can't infer anything\n                if (val) {\n                    if (datetime_1.isDateTime(val)) {\n                        parse[filter.field] = 'date';\n                    }\n                    else if (vega_util_1.isNumber(val)) {\n                        parse[filter.field] = 'number';\n                    }\n                    else if (vega_util_1.isString(val)) {\n                        parse[filter.field] = 'string';\n                    }\n                }\n                if (filter.timeUnit) {\n                    parse[filter.field] = 'date';\n                }\n            }\n        });\n        if (util_1.keys(parse).length === 0) {\n            return null;\n        }\n        return this.makeWithAncestors(parent, {}, parse, ancestorParse);\n    };\n    /**\n     * Creates a parse node for implicit parsing from a model and updates ancestorParse.\n     */\n    ParseNode.makeImplicitFromEncoding = function (parent, model, ancestorParse) {\n        var implicit = {};\n        if (model_1.isUnitModel(model) || model_1.isFacetModel(model)) {\n            // Parse encoded fields\n            model.forEachFieldDef(function (fieldDef) {\n                if (fielddef_1.isTimeFieldDef(fieldDef)) {\n                    implicit[fieldDef.field] = 'date';\n                }\n                else if (fielddef_1.isNumberFieldDef(fieldDef)) {\n                    if (!aggregate_1.isCountingAggregateOp(fieldDef.aggregate)) {\n                        implicit[fieldDef.field] = 'number';\n                    }\n                }\n                else if (util_1.accessPathDepth(fieldDef.field) > 1) {\n                    // For non-date/non-number (strings and booleans), derive a flattened field for a referenced nested field.\n                    // (Parsing numbers / dates already flattens numeric and temporal fields.)\n                    if (!(fieldDef.field in implicit)) {\n                        implicit[fieldDef.field] = 'flatten';\n                    }\n                }\n                else if (fielddef_1.isScaleFieldDef(fieldDef) && sort_1.isSortField(fieldDef.sort) && util_1.accessPathDepth(fieldDef.sort.field) > 1) {\n                    // Flatten fields that we sort by but that are not otherwise flattened.\n                    if (!(fieldDef.sort.field in implicit)) {\n                        implicit[fieldDef.sort.field] = 'flatten';\n                    }\n                }\n            });\n        }\n        return this.makeWithAncestors(parent, {}, implicit, ancestorParse);\n    };\n    /**\n     * Creates a parse node from \"explicit\" parse and \"implicit\" parse and updates ancestorParse.\n     */\n    ParseNode.makeWithAncestors = function (parent, explicit, implicit, ancestorParse) {\n        // We should not parse what has already been parsed in a parent (explicitly or implicitly) or what has been derived (maked as \"derived\"). We also don't need to flatten a field that has already been parsed.\n        for (var _i = 0, _a = util_1.keys(implicit); _i < _a.length; _i++) {\n            var field = _a[_i];\n            var parsedAs = ancestorParse.getWithExplicit(field);\n            if (parsedAs.value !== undefined) {\n                // We always ignore derived fields even if they are implicitly defined because we expect users to create the right types.\n                if (parsedAs.explicit || parsedAs.value === implicit[field] || parsedAs.value === 'derived' || implicit[field] === 'flatten') {\n                    delete implicit[field];\n                }\n                else {\n                    log.warn(log.message.differentParse(field, implicit[field], parsedAs.value));\n                }\n            }\n        }\n        for (var _b = 0, _c = util_1.keys(explicit); _b < _c.length; _b++) {\n            var field = _c[_b];\n            var parsedAs = ancestorParse.get(field);\n            if (parsedAs !== undefined) {\n                // Don't parse a field again if it has been parsed with the same type already.\n                if (parsedAs === explicit[field]) {\n                    delete explicit[field];\n                }\n                else {\n                    log.warn(log.message.differentParse(field, explicit[field], parsedAs));\n                }\n            }\n        }\n        var parse = new split_1.Split(explicit, implicit);\n        // add the format parse from this model so that children don't parse the same field again\n        ancestorParse.copyAll(parse);\n        // copy only non-null parses\n        var p = {};\n        for (var _d = 0, _e = util_1.keys(parse.combine()); _d < _e.length; _d++) {\n            var key = _e[_d];\n            var val = parse.get(key);\n            if (val !== null) {\n                p[key] = val;\n            }\n        }\n        if (util_1.keys(p).length === 0 || ancestorParse.parseNothing) {\n            return null;\n        }\n        return new ParseNode(parent, p);\n    };\n    Object.defineProperty(ParseNode.prototype, \"parse\", {\n        get: function () {\n            return this._parse;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ParseNode.prototype.merge = function (other) {\n        this._parse = tslib_1.__assign({}, this._parse, other.parse);\n        other.remove();\n    };\n    /**\n     * Assemble an object for Vega's format.parse property.\n     */\n    ParseNode.prototype.assembleFormatParse = function () {\n        var formatParse = {};\n        for (var _i = 0, _a = util_1.keys(this._parse); _i < _a.length; _i++) {\n            var field = _a[_i];\n            var p = this._parse[field];\n            if (util_1.accessPathDepth(field) === 1) {\n                formatParse[field] = p;\n            }\n        }\n        return formatParse;\n    };\n    // format parse depends and produces all fields in its parse\n    ParseNode.prototype.producedFields = function () {\n        return vega_util_1.toSet(util_1.keys(this._parse));\n    };\n    ParseNode.prototype.dependentFields = function () {\n        return vega_util_1.toSet(util_1.keys(this._parse));\n    };\n    ParseNode.prototype.assembleTransforms = function (onlyNested) {\n        var _this = this;\n        if (onlyNested === void 0) { onlyNested = false; }\n        return util_1.keys(this._parse)\n            .filter(function (field) { return onlyNested ? util_1.accessPathDepth(field) > 1 : true; })\n            .map(function (field) {\n            var expr = parseExpression(field, _this._parse[field]);\n            if (!expr) {\n                return null;\n            }\n            var formula = {\n                type: 'formula',\n                expr: expr,\n                as: util_1.removePathFromField(field) // Vega output is always flattened\n            };\n            return formula;\n        }).filter(function (t) { return t !== null; });\n    };\n    return ParseNode;\n}(dataflow_1.DataFlowNode));\nexports.ParseNode = ParseNode;\n"},"sourceMaps":{"js":{"version":3,"file":"formatparse.js","sourceRoot":"","sources":["../../../../src/compile/data/formatparse.ts"],"names":[],"mappings":"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","sourcesContent":["import {isNumber, isString, toSet} from 'vega-util';\nimport {AncestorParse} from '.';\nimport {isCountingAggregateOp} from '../../aggregate';\nimport {DateTime, isDateTime} from '../../datetime';\nimport {isNumberFieldDef, isScaleFieldDef, isTimeFieldDef} from '../../fielddef';\nimport * as log from '../../log';\nimport {forEachLeaf} from '../../logical';\nimport {isFieldEqualPredicate, isFieldOneOfPredicate, isFieldPredicate, isFieldRangePredicate} from '../../predicate';\nimport {isSortField} from '../../sort';\nimport {FilterTransform} from '../../transform';\nimport {accessPathDepth, accessPathWithDatum, Dict, duplicate, keys, removePathFromField, StringSet} from '../../util';\nimport {VgFormulaTransform} from '../../vega.schema';\nimport {isFacetModel, isUnitModel, Model} from '../model';\nimport {Split} from '../split';\nimport {DataFlowNode} from './dataflow';\n\n\n/**\n * @param field The field.\n * @param parse What to parse the field as.\n */\nfunction parseExpression(field: string, parse: string): string {\n  const f = accessPathWithDatum(field);\n  if (parse === 'number') {\n    return `toNumber(${f})`;\n  } else if (parse === 'boolean') {\n    return `toBoolean(${f})`;\n  } else if (parse === 'string') {\n    return `toString(${f})`;\n  } else if (parse === 'date') {\n    return `toDate(${f})`;\n  } else if (parse === 'flatten') {\n    return f;\n  } else if (parse.indexOf('date:') === 0) {\n    const specifier = parse.slice(5, parse.length);\n    return `timeParse(${f},${specifier})`;\n  } else if (parse.indexOf('utc:') === 0) {\n    const specifier = parse.slice(4, parse.length);\n    return `utcParse(${f},${specifier})`;\n  } else {\n    log.warn(log.message.unrecognizedParse(parse));\n    return null;\n  }\n}\n\nexport class ParseNode extends DataFlowNode {\n  private _parse: Dict<string>;\n\n  public clone() {\n    return new ParseNode(null, duplicate(this._parse));\n  }\n\n  constructor(parent: DataFlowNode, parse: Dict<string>) {\n    super(parent);\n\n    this._parse = parse;\n  }\n\n  /**\n   * Creates a parse node from a data.format.parse and updates ancestorParse.\n   */\n  public static makeExplicit(parent: DataFlowNode, model: Model, ancestorParse: AncestorParse) {\n    // Custom parse\n    let explicit = {};\n    const data = model.data;\n    if (data && data.format && data.format.parse) {\n      explicit = data.format.parse;\n    }\n\n    return this.makeWithAncestors(parent, explicit, {}, ancestorParse);\n  }\n\n  public static makeImplicitFromFilterTransform(parent: DataFlowNode, transform: FilterTransform, ancestorParse: AncestorParse) {\n    const parse = {};\n    forEachLeaf(transform.filter, filter => {\n      if (isFieldPredicate(filter)) {\n        // Automatically add a parse node for filters with filter objects\n        let val: string | number | boolean | DateTime = null;\n\n        // For EqualFilter, just use the equal property.\n        // For RangeFilter and OneOfFilter, all array members should have\n        // the same type, so we only use the first one.\n        if (isFieldEqualPredicate(filter)) {\n          val = filter.equal;\n        } else if (isFieldRangePredicate(filter)) {\n          val = filter.range[0];\n        } else if (isFieldOneOfPredicate(filter)) {\n          val = (filter.oneOf || filter['in'])[0];\n        } // else -- for filter expression, we can't infer anything\n        if (val) {\n          if (isDateTime(val)) {\n            parse[filter.field] = 'date';\n          } else if (isNumber(val)) {\n            parse[filter.field] = 'number';\n          } else if (isString(val)) {\n            parse[filter.field] = 'string';\n          }\n        }\n\n        if (filter.timeUnit) {\n          parse[filter.field] = 'date';\n        }\n      }\n    });\n\n    if (keys(parse).length === 0) {\n      return null;\n    }\n\n    return this.makeWithAncestors(parent, {}, parse, ancestorParse);\n  }\n\n  /**\n   * Creates a parse node for implicit parsing from a model and updates ancestorParse.\n   */\n  public static makeImplicitFromEncoding(parent: DataFlowNode, model: Model, ancestorParse: AncestorParse) {\n    const implicit = {};\n\n    if (isUnitModel(model) || isFacetModel(model)) {\n      // Parse encoded fields\n      model.forEachFieldDef(fieldDef => {\n        if (isTimeFieldDef(fieldDef)) {\n          implicit[fieldDef.field] = 'date';\n        } else if (isNumberFieldDef(fieldDef)) {\n          if (!isCountingAggregateOp(fieldDef.aggregate)) {\n            implicit[fieldDef.field] = 'number';\n          }\n        } else if (accessPathDepth(fieldDef.field) > 1) {\n          // For non-date/non-number (strings and booleans), derive a flattened field for a referenced nested field.\n          // (Parsing numbers / dates already flattens numeric and temporal fields.)\n          if (!(fieldDef.field in implicit)) {\n            implicit[fieldDef.field] = 'flatten';\n          }\n        } else if (isScaleFieldDef(fieldDef) && isSortField(fieldDef.sort) && accessPathDepth(fieldDef.sort.field) > 1) {\n          // Flatten fields that we sort by but that are not otherwise flattened.\n          if (!(fieldDef.sort.field in implicit)) {\n            implicit[fieldDef.sort.field] = 'flatten';\n          }\n        }\n      });\n    }\n\n    return this.makeWithAncestors(parent, {}, implicit, ancestorParse);\n  }\n\n  /**\n   * Creates a parse node from \"explicit\" parse and \"implicit\" parse and updates ancestorParse.\n   */\n  private static makeWithAncestors(parent: DataFlowNode, explicit: Dict<string>, implicit: Dict<string>, ancestorParse: AncestorParse) {\n    // We should not parse what has already been parsed in a parent (explicitly or implicitly) or what has been derived (maked as \"derived\"). We also don't need to flatten a field that has already been parsed.\n    for (const field of keys(implicit)) {\n      const parsedAs = ancestorParse.getWithExplicit(field);\n      if (parsedAs.value !== undefined) {\n        // We always ignore derived fields even if they are implicitly defined because we expect users to create the right types.\n        if (parsedAs.explicit || parsedAs.value === implicit[field] || parsedAs.value === 'derived' || implicit[field] === 'flatten') {\n          delete implicit[field];\n        } else {\n          log.warn(log.message.differentParse(field, implicit[field], parsedAs.value));\n        }\n      }\n    }\n\n    for (const field of keys(explicit)) {\n      const parsedAs = ancestorParse.get(field);\n      if (parsedAs !== undefined) {\n        // Don't parse a field again if it has been parsed with the same type already.\n        if (parsedAs === explicit[field]) {\n          delete explicit[field];\n        } else {\n          log.warn(log.message.differentParse(field, explicit[field], parsedAs));\n        }\n      }\n    }\n\n    const parse = new Split(explicit, implicit);\n\n    // add the format parse from this model so that children don't parse the same field again\n    ancestorParse.copyAll(parse);\n\n    // copy only non-null parses\n    const p = {};\n    for (const key of keys(parse.combine())) {\n      const val = parse.get(key);\n      if (val !== null) {\n        p[key] = val;\n      }\n    }\n\n    if (keys(p).length === 0 || ancestorParse.parseNothing) {\n      return null;\n    }\n\n    return new ParseNode(parent, p);\n  }\n\n  public get parse() {\n    return this._parse;\n  }\n\n  public merge(other: ParseNode) {\n    this._parse = {...this._parse, ...other.parse};\n    other.remove();\n  }\n\n  /**\n   * Assemble an object for Vega's format.parse property.\n   */\n  public assembleFormatParse() {\n    const formatParse = {};\n    for (const field of keys(this._parse)) {\n      const p = this._parse[field];\n      if (accessPathDepth(field) === 1) {\n        formatParse[field] = p;\n      }\n    }\n    return formatParse;\n  }\n\n  // format parse depends and produces all fields in its parse\n  public producedFields(): StringSet {\n    return toSet(keys(this._parse));\n  }\n\n  public dependentFields(): StringSet {\n    return toSet(keys(this._parse));\n  }\n\n  public assembleTransforms(onlyNested = false): VgFormulaTransform[] {\n    return keys(this._parse)\n      .filter(field => onlyNested ? accessPathDepth(field) > 1 : true)\n      .map(field => {\n        const expr = parseExpression(field, this._parse[field]);\n        if (!expr) {\n          return null;\n        }\n\n        const formula: VgFormulaTransform = {\n          type: 'formula',\n          expr,\n          as: removePathFromField(field)  // Vega output is always flattened\n        };\n        return formula;\n      }).filter(t => t !== null);\n  }\n}\n"]}},"error":null,"hash":"ed30572f2aaa3463ff11b01d7ed05387","cacheData":{"env":{}}}