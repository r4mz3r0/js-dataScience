{"id":"node_modules/vega-lite/build/src/compile/data/aggregate.js","dependencies":[{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/aggregate.js.map","includedInParent":true,"mtime":499162500000},{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/package.json","includedInParent":true,"mtime":1593715260815},{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/package.json","includedInParent":true,"mtime":499162500000},{"name":"tslib","loc":{"line":3,"column":22},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/aggregate.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/tslib/tslib.es6.js"},{"name":"../../channel","loc":{"line":4,"column":24},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/aggregate.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/channel.js"},{"name":"../../fielddef","loc":{"line":5,"column":25},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/aggregate.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/fielddef.js"},{"name":"../../log","loc":{"line":6,"column":39},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/aggregate.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/log.js"},{"name":"../../util","loc":{"line":7,"column":21},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/aggregate.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/util.js"},{"name":"../common","loc":{"line":8,"column":23},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/aggregate.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/common.js"},{"name":"./dataflow","loc":{"line":9,"column":25},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/aggregate.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/dataflow.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar channel_1 = require(\"../../channel\");\nvar fielddef_1 = require(\"../../fielddef\");\nvar log = tslib_1.__importStar(require(\"../../log\"));\nvar util_1 = require(\"../../util\");\nvar common_1 = require(\"../common\");\nvar dataflow_1 = require(\"./dataflow\");\nfunction addDimension(dims, channel, fieldDef) {\n    if (fieldDef.bin) {\n        dims[fielddef_1.vgField(fieldDef, {})] = true;\n        dims[fielddef_1.vgField(fieldDef, { binSuffix: 'end' })] = true;\n        if (common_1.binRequiresRange(fieldDef, channel)) {\n            dims[fielddef_1.vgField(fieldDef, { binSuffix: 'range' })] = true;\n        }\n    }\n    else {\n        dims[fielddef_1.vgField(fieldDef)] = true;\n    }\n    return dims;\n}\nfunction mergeMeasures(parentMeasures, childMeasures) {\n    for (var f in childMeasures) {\n        if (childMeasures.hasOwnProperty(f)) {\n            // when we merge a measure, we either have to add an aggregation operator or even a new field\n            var ops = childMeasures[f];\n            for (var op in ops) {\n                if (ops.hasOwnProperty(op)) {\n                    if (f in parentMeasures) {\n                        // add operator to existing measure field\n                        parentMeasures[f][op] = ops[op];\n                    }\n                    else {\n                        parentMeasures[f] = { op: ops[op] };\n                    }\n                }\n            }\n        }\n    }\n}\nvar AggregateNode = /** @class */ (function (_super) {\n    tslib_1.__extends(AggregateNode, _super);\n    /**\n     * @param dimensions string set for dimensions\n     * @param measures dictionary mapping field name => dict of aggregation functions and names to use\n     */\n    function AggregateNode(parent, dimensions, measures) {\n        var _this = _super.call(this, parent) || this;\n        _this.dimensions = dimensions;\n        _this.measures = measures;\n        return _this;\n    }\n    AggregateNode.prototype.clone = function () {\n        return new AggregateNode(null, tslib_1.__assign({}, this.dimensions), util_1.duplicate(this.measures));\n    };\n    AggregateNode.makeFromEncoding = function (parent, model) {\n        var isAggregate = false;\n        model.forEachFieldDef(function (fd) {\n            if (fd.aggregate) {\n                isAggregate = true;\n            }\n        });\n        var meas = {};\n        var dims = {};\n        if (!isAggregate) {\n            // no need to create this node if the model has no aggregation\n            return null;\n        }\n        model.forEachFieldDef(function (fieldDef, channel) {\n            var aggregate = fieldDef.aggregate, field = fieldDef.field;\n            if (aggregate) {\n                if (aggregate === 'count') {\n                    meas['*'] = meas['*'] || {};\n                    meas['*']['count'] = fielddef_1.vgField(fieldDef);\n                }\n                else {\n                    meas[field] = meas[field] || {};\n                    meas[field][aggregate] = fielddef_1.vgField(fieldDef);\n                    // For scale channel with domain === 'unaggregated', add min/max so we can use their union as unaggregated domain\n                    if (channel_1.isScaleChannel(channel) && model.scaleDomain(channel) === 'unaggregated') {\n                        meas[field]['min'] = fielddef_1.vgField({ field: field, aggregate: 'min' });\n                        meas[field]['max'] = fielddef_1.vgField({ field: field, aggregate: 'max' });\n                    }\n                }\n            }\n            else {\n                addDimension(dims, channel, fieldDef);\n            }\n        });\n        if ((util_1.keys(dims).length + util_1.keys(meas).length) === 0) {\n            return null;\n        }\n        return new AggregateNode(parent, dims, meas);\n    };\n    AggregateNode.makeFromTransform = function (parent, t) {\n        var dims = {};\n        var meas = {};\n        for (var _i = 0, _a = t.aggregate; _i < _a.length; _i++) {\n            var s = _a[_i];\n            var op = s.op, field = s.field, as = s.as;\n            if (op) {\n                if (op === 'count') {\n                    meas['*'] = meas['*'] || {};\n                    meas['*']['count'] = as || fielddef_1.vgField(s);\n                }\n                else {\n                    meas[field] = meas[field] || {};\n                    meas[field][op] = as || fielddef_1.vgField(s);\n                }\n            }\n        }\n        for (var _b = 0, _c = t.groupby || []; _b < _c.length; _b++) {\n            var s = _c[_b];\n            dims[s] = true;\n        }\n        if ((util_1.keys(dims).length + util_1.keys(meas).length) === 0) {\n            return null;\n        }\n        return new AggregateNode(parent, dims, meas);\n    };\n    AggregateNode.prototype.merge = function (other) {\n        if (!util_1.differ(this.dimensions, other.dimensions)) {\n            mergeMeasures(this.measures, other.measures);\n            other.remove();\n        }\n        else {\n            log.debug('different dimensions, cannot merge');\n        }\n    };\n    AggregateNode.prototype.addDimensions = function (fields) {\n        var _this = this;\n        fields.forEach(function (f) { return _this.dimensions[f] = true; });\n    };\n    AggregateNode.prototype.dependentFields = function () {\n        var out = {};\n        util_1.keys(this.dimensions).forEach(function (f) { return out[f] = true; });\n        util_1.keys(this.measures).forEach(function (m) { return out[m] = true; });\n        return out;\n    };\n    AggregateNode.prototype.producedFields = function () {\n        var _this = this;\n        var out = {};\n        util_1.keys(this.measures).forEach(function (field) {\n            util_1.keys(_this.measures[field]).forEach(function (op) {\n                out[op + \"_\" + field] = true;\n            });\n        });\n        return out;\n    };\n    AggregateNode.prototype.assemble = function () {\n        var ops = [];\n        var fields = [];\n        var as = [];\n        for (var _i = 0, _a = util_1.keys(this.measures); _i < _a.length; _i++) {\n            var field = _a[_i];\n            for (var _b = 0, _c = util_1.keys(this.measures[field]); _b < _c.length; _b++) {\n                var op = _c[_b];\n                as.push(this.measures[field][op]);\n                ops.push(op);\n                fields.push(field);\n            }\n        }\n        var result = {\n            type: 'aggregate',\n            groupby: util_1.keys(this.dimensions),\n            ops: ops,\n            fields: fields,\n            as: as\n        };\n        return result;\n    };\n    return AggregateNode;\n}(dataflow_1.DataFlowNode));\nexports.AggregateNode = AggregateNode;\n"},"sourceMaps":{"js":{"version":3,"file":"aggregate.js","sourceRoot":"","sources":["../../../../src/compile/data/aggregate.ts"],"names":[],"mappings":"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","sourcesContent":["import {AggregateOp} from 'vega';\n\nimport {Channel, isScaleChannel} from '../../channel';\nimport {FieldDef, vgField} from '../../fielddef';\nimport * as log from '../../log';\nimport {AggregateTransform} from '../../transform';\nimport {Dict, differ, duplicate, keys, StringSet} from '../../util';\nimport {VgAggregateTransform} from '../../vega.schema';\nimport {binRequiresRange} from '../common';\nimport {UnitModel} from './../unit';\nimport {DataFlowNode} from './dataflow';\n\nfunction addDimension(dims: {[field: string]: boolean}, channel: Channel, fieldDef: FieldDef<string>) {\n  if (fieldDef.bin) {\n    dims[vgField(fieldDef, {})] = true;\n    dims[vgField(fieldDef, {binSuffix: 'end'})] = true;\n\n    if (binRequiresRange(fieldDef, channel)) {\n      dims[vgField(fieldDef, {binSuffix: 'range'})] = true;\n    }\n  } else {\n    dims[vgField(fieldDef)] = true;\n  }\n  return dims;\n}\n\nfunction mergeMeasures(parentMeasures: Dict<Dict<string>>, childMeasures: Dict<Dict<string>>) {\n  for (const f in childMeasures) {\n    if (childMeasures.hasOwnProperty(f)) {\n      // when we merge a measure, we either have to add an aggregation operator or even a new field\n      const ops = childMeasures[f];\n      for (const op in ops) {\n        if (ops.hasOwnProperty(op)) {\n          if (f in parentMeasures) {\n            // add operator to existing measure field\n            parentMeasures[f][op] = ops[op];\n          } else {\n            parentMeasures[f] = {op: ops[op]};\n          }\n        }\n      }\n    }\n  }\n}\n\nexport class AggregateNode extends DataFlowNode {\n  public clone() {\n    return new AggregateNode(null, {...this.dimensions}, duplicate(this.measures));\n  }\n\n  /**\n   * @param dimensions string set for dimensions\n   * @param measures dictionary mapping field name => dict of aggregation functions and names to use\n   */\n  constructor(parent: DataFlowNode, private dimensions: StringSet, private measures: Dict<{[key in AggregateOp]?: string}>) {\n    super(parent);\n  }\n\n  public static makeFromEncoding(parent: DataFlowNode, model: UnitModel): AggregateNode {\n    let isAggregate = false;\n    model.forEachFieldDef(fd => {\n      if (fd.aggregate) {\n        isAggregate = true;\n      }\n    });\n\n    const meas = {};\n    const dims = {};\n\n    if (!isAggregate) {\n      // no need to create this node if the model has no aggregation\n      return null;\n    }\n\n    model.forEachFieldDef((fieldDef, channel) => {\n      const {aggregate, field} = fieldDef;\n      if (aggregate) {\n        if (aggregate === 'count') {\n          meas['*'] = meas['*'] || {};\n          meas['*']['count'] = vgField(fieldDef);\n        } else {\n          meas[field] = meas[field] || {};\n          meas[field][aggregate] = vgField(fieldDef);\n\n          // For scale channel with domain === 'unaggregated', add min/max so we can use their union as unaggregated domain\n          if (isScaleChannel(channel) && model.scaleDomain(channel) === 'unaggregated') {\n            meas[field]['min'] = vgField({field, aggregate: 'min'});\n            meas[field]['max'] = vgField({field, aggregate: 'max'});\n          }\n        }\n      } else {\n        addDimension(dims, channel, fieldDef);\n      }\n    });\n\n    if ((keys(dims).length + keys(meas).length) === 0) {\n      return null;\n    }\n\n    return new AggregateNode(parent, dims, meas);\n  }\n\n  public static makeFromTransform(parent: DataFlowNode, t: AggregateTransform): AggregateNode {\n    const dims = {};\n    const meas = {};\n\n    for (const s of t.aggregate) {\n      const {op, field, as} = s;\n      if (op) {\n        if (op === 'count') {\n          meas['*'] = meas['*'] || {};\n          meas['*']['count'] = as || vgField(s);\n        } else {\n          meas[field] = meas[field] || {};\n          meas[field][op] = as || vgField(s);\n        }\n      }\n    }\n\n    for (const s of t.groupby || []) {\n      dims[s] = true;\n    }\n\n    if ((keys(dims).length + keys(meas).length) === 0) {\n      return null;\n    }\n\n    return new AggregateNode(parent, dims, meas);\n  }\n\n  public merge(other: AggregateNode) {\n    if (!differ(this.dimensions, other.dimensions)) {\n      mergeMeasures(this.measures, other.measures);\n      other.remove();\n    } else {\n      log.debug('different dimensions, cannot merge');\n    }\n  }\n\n  public addDimensions(fields: string[]) {\n    fields.forEach(f => this.dimensions[f] = true);\n  }\n\n  public dependentFields() {\n    const out = {};\n\n    keys(this.dimensions).forEach(f => out[f] = true);\n    keys(this.measures).forEach(m => out[m] = true);\n\n    return out;\n  }\n\n  public producedFields() {\n    const out = {};\n\n    keys(this.measures).forEach(field => {\n      keys(this.measures[field]).forEach(op => {\n        out[`${op}_${field}`] = true;\n      });\n    });\n\n    return out;\n  }\n\n  public assemble(): VgAggregateTransform {\n    const ops: AggregateOp[] = [];\n    const fields: string[] = [];\n    const as: string[] = [];\n\n    for (const field of keys(this.measures)) {\n      for (const op of keys(this.measures[field])) {\n        as.push(this.measures[field][op]);\n        ops.push(op);\n        fields.push(field);\n      }\n    }\n\n    const result: VgAggregateTransform = {\n      type: 'aggregate',\n      groupby: keys(this.dimensions),\n      ops,\n      fields,\n      as\n    };\n\n    return result;\n  }\n}\n"]}},"error":null,"hash":"ad8938f2251891390ff8172962e34119","cacheData":{"env":{}}}