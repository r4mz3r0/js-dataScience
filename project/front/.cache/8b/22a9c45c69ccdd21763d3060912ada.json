{"id":"node_modules/vega-lite/build/src/compile/mark/geoshape.js","dependencies":[{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/geoshape.js.map","includedInParent":true,"mtime":499162500000},{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/package.json","includedInParent":true,"mtime":1593715260815},{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/package.json","includedInParent":true,"mtime":499162500000},{"name":"tslib","loc":{"line":3,"column":22},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/geoshape.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/tslib/tslib.es6.js"},{"name":"./mixins","loc":{"line":4,"column":42},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/geoshape.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/mixins.js"},{"name":"../../fielddef","loc":{"line":5,"column":25},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/geoshape.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/fielddef.js"},{"name":"../../type","loc":{"line":6,"column":21},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/geoshape.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/type.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar mixins = tslib_1.__importStar(require(\"./mixins\"));\nvar fielddef_1 = require(\"../../fielddef\");\nvar type_1 = require(\"../../type\");\nexports.geoshape = {\n    vgMark: 'shape',\n    encodeEntry: function (model) {\n        return tslib_1.__assign({}, mixins.baseEncodeEntry(model, { size: 'ignore', orient: 'ignore' }));\n    },\n    postEncodingTransform: function (model) {\n        var encoding = model.encoding;\n        var shapeDef = encoding.shape;\n        var transform = tslib_1.__assign({ type: 'geoshape', projection: model.projectionName() }, (shapeDef && fielddef_1.isFieldDef(shapeDef) && shapeDef.type === type_1.GEOJSON ? { field: fielddef_1.vgField(shapeDef, { expr: 'datum' }) } : {}));\n        return [transform];\n    }\n};\n"},"sourceMaps":{"js":{"version":3,"file":"geoshape.js","sourceRoot":"","sources":["../../../../src/compile/mark/geoshape.ts"],"names":[],"mappings":";;;AACA,uDAAmC;AAEnC,2CAAmD;AACnD,mCAAmC;AAItB,QAAA,QAAQ,GAAiB;IACpC,MAAM,EAAE,OAAO;IACf,WAAW,EAAE,UAAC,KAAgB;QAC5B,4BACK,MAAM,CAAC,eAAe,CAAC,KAAK,EAAE,EAAC,IAAI,EAAE,QAAQ,EAAE,MAAM,EAAE,QAAQ,EAAC,CAAC,EACpE;IACJ,CAAC;IACD,qBAAqB,EAAE,UAAC,KAAgB;QAC/B,IAAA,yBAAQ,CAAU;QACzB,IAAM,QAAQ,GAAG,QAAQ,CAAC,KAAK,CAAC;QAEhC,IAAM,SAAS,sBACb,IAAI,EAAE,UAAU,EAChB,UAAU,EAAE,KAAK,CAAC,cAAc,EAAE,IAE/B,CAAC,QAAQ,IAAI,qBAAU,CAAC,QAAQ,CAAC,IAAI,QAAQ,CAAC,IAAI,KAAK,cAAO,CAAC,CAAC,CAAC,EAAC,KAAK,EAAE,kBAAO,CAAC,QAAQ,EAAE,EAAC,IAAI,EAAE,OAAO,EAAC,CAAC,EAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CACtH,CAAC;QACF,OAAO,CAAC,SAAS,CAAC,CAAC;IACrB,CAAC;CACF,CAAC","sourcesContent":["import {UnitModel} from '../unit';\nimport * as mixins from './mixins';\n\nimport {isFieldDef, vgField} from '../../fielddef';\nimport {GEOJSON} from '../../type';\nimport {VgGeoShapeTransform, VgPostEncodingTransform} from '../../vega.schema';\nimport {MarkCompiler} from './base';\n\nexport const geoshape: MarkCompiler = {\n  vgMark: 'shape',\n  encodeEntry: (model: UnitModel) => {\n    return {\n      ...mixins.baseEncodeEntry(model, {size: 'ignore', orient: 'ignore'})\n    };\n  },\n  postEncodingTransform: (model: UnitModel): VgPostEncodingTransform[] => {\n    const {encoding} = model;\n    const shapeDef = encoding.shape;\n\n    const transform: VgGeoShapeTransform = {\n      type: 'geoshape',\n      projection: model.projectionName(),\n      // as: 'shape',\n      ...(shapeDef && isFieldDef(shapeDef) && shapeDef.type === GEOJSON ? {field: vgField(shapeDef, {expr: 'datum'})} : {})\n    };\n    return [transform];\n  }\n};\n"]}},"error":null,"hash":"8881fcfbcd0722861efecf3f8fcbf37d","cacheData":{"env":{}}}