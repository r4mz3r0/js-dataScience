{"id":"node_modules/vega-lite/build/src/compile/layoutsize/assemble.js","dependencies":[{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/layoutsize/assemble.js.map","includedInParent":true,"mtime":499162500000},{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/package.json","includedInParent":true,"mtime":1593715260815},{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/package.json","includedInParent":true,"mtime":499162500000},{"name":"../../scale","loc":{"line":3,"column":22},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/layoutsize/assemble.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/scale.js"},{"name":"../../vega.schema","loc":{"line":4,"column":28},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/layoutsize/assemble.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/vega.schema.js"},{"name":"../model","loc":{"line":5,"column":22},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/layoutsize/assemble.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/model.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar scale_1 = require(\"../../scale\");\nvar vega_schema_1 = require(\"../../vega.schema\");\nvar model_1 = require(\"../model\");\nfunction assembleLayoutSignals(model) {\n    return [].concat(sizeSignals(model, 'width'), sizeSignals(model, 'height'));\n}\nexports.assembleLayoutSignals = assembleLayoutSignals;\nfunction sizeSignals(model, sizeType) {\n    var channel = sizeType === 'width' ? 'x' : 'y';\n    var size = model.component.layoutSize.get(sizeType);\n    if (!size || size === 'merged') {\n        return [];\n    }\n    // Read size signal name from name map, just in case it is the top-level size signal that got renamed.\n    var name = model.getSizeSignalRef(sizeType).signal;\n    if (size === 'range-step') {\n        var scaleComponent = model.getScaleComponent(channel);\n        if (scaleComponent) {\n            var type = scaleComponent.get('type');\n            var range = scaleComponent.get('range');\n            if (scale_1.hasDiscreteDomain(type) && vega_schema_1.isVgRangeStep(range)) {\n                var scaleName = model.scaleName(channel);\n                if (model_1.isFacetModel(model.parent)) {\n                    // If parent is facet and this is an independent scale, return only signal signal\n                    // as the width/height will be calculated using the cardinality from\n                    // facet's aggregate rather than reading from scale domain\n                    var parentResolve = model.parent.component.resolve;\n                    if (parentResolve.scale[channel] === 'independent') {\n                        return [stepSignal(scaleName, range)];\n                    }\n                }\n                return [\n                    stepSignal(scaleName, range),\n                    {\n                        name: name,\n                        update: sizeExpr(scaleName, scaleComponent, \"domain('\" + scaleName + \"').length\")\n                    }\n                ];\n            }\n        }\n        /* istanbul ignore next: Condition should not happen -- only for warning in development. */\n        throw new Error('layout size is range step although there is no rangeStep.');\n    }\n    else {\n        return [{\n                name: name,\n                value: size\n            }];\n    }\n}\nexports.sizeSignals = sizeSignals;\nfunction stepSignal(scaleName, range) {\n    return {\n        name: scaleName + '_step',\n        value: range.step,\n    };\n}\nfunction sizeExpr(scaleName, scaleComponent, cardinality) {\n    var type = scaleComponent.get('type');\n    var padding = scaleComponent.get('padding');\n    var paddingOuter = scaleComponent.get('paddingOuter');\n    paddingOuter = paddingOuter !== undefined ? paddingOuter : padding;\n    var paddingInner = scaleComponent.get('paddingInner');\n    paddingInner = type === 'band' ?\n        // only band has real paddingInner\n        (paddingInner !== undefined ? paddingInner : padding) :\n        // For point, as calculated in https://github.com/vega/vega-scale/blob/master/src/band.js#L128,\n        // it's equivalent to have paddingInner = 1 since there is only n-1 steps between n points.\n        1;\n    return \"bandspace(\" + cardinality + \", \" + paddingInner + \", \" + paddingOuter + \") * \" + scaleName + \"_step\";\n}\nexports.sizeExpr = sizeExpr;\n"},"sourceMaps":{"js":{"version":3,"file":"assemble.js","sourceRoot":"","sources":["../../../../src/compile/layoutsize/assemble.ts"],"names":[],"mappings":"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","sourcesContent":["\nimport {hasDiscreteDomain} from '../../scale';\nimport {isVgRangeStep, VgRangeStep, VgSignal} from '../../vega.schema';\nimport {isFacetModel, Model} from '../model';\nimport {ScaleComponent} from '../scale/component';\n\nexport function assembleLayoutSignals(model: Model): VgSignal[] {\n  return [].concat(\n    sizeSignals(model, 'width'),\n    sizeSignals(model, 'height')\n  );\n}\n\nexport function sizeSignals(model: Model, sizeType: 'width' | 'height'): VgSignal[] {\n  const channel = sizeType === 'width' ? 'x' : 'y';\n  const size = model.component.layoutSize.get(sizeType);\n  if (!size || size === 'merged') {\n    return [];\n  }\n\n  // Read size signal name from name map, just in case it is the top-level size signal that got renamed.\n  const name = model.getSizeSignalRef(sizeType).signal;\n\n  if (size === 'range-step') {\n    const scaleComponent = model.getScaleComponent(channel);\n\n    if (scaleComponent) {\n      const type = scaleComponent.get('type');\n      const range = scaleComponent.get('range');\n\n      if (hasDiscreteDomain(type) && isVgRangeStep(range)) {\n        const scaleName = model.scaleName(channel);\n\n        if (isFacetModel(model.parent)) {\n          // If parent is facet and this is an independent scale, return only signal signal\n          // as the width/height will be calculated using the cardinality from\n          // facet's aggregate rather than reading from scale domain\n          const parentResolve = model.parent.component.resolve;\n          if (parentResolve.scale[channel] === 'independent') {\n            return [stepSignal(scaleName, range)];\n          }\n        }\n\n        return [\n          stepSignal(scaleName, range),\n          {\n            name,\n            update: sizeExpr(scaleName, scaleComponent, `domain('${scaleName}').length`)\n          }\n        ];\n      }\n    }\n    /* istanbul ignore next: Condition should not happen -- only for warning in development. */\n    throw new Error('layout size is range step although there is no rangeStep.');\n  } else {\n    return [{\n      name,\n      value: size\n    }];\n  }\n}\n\nfunction stepSignal(scaleName: string, range: VgRangeStep): VgSignal {\n  return {\n    name: scaleName + '_step',\n    value: range.step,\n  };\n}\n\nexport function sizeExpr(scaleName: string, scaleComponent: ScaleComponent, cardinality: string) {\n  const type = scaleComponent.get('type');\n  const padding = scaleComponent.get('padding');\n  let paddingOuter = scaleComponent.get('paddingOuter');\n  paddingOuter = paddingOuter !== undefined ? paddingOuter : padding;\n\n  let paddingInner = scaleComponent.get('paddingInner');\n  paddingInner = type === 'band' ?\n    // only band has real paddingInner\n    (paddingInner !== undefined ? paddingInner : padding) :\n    // For point, as calculated in https://github.com/vega/vega-scale/blob/master/src/band.js#L128,\n    // it's equivalent to have paddingInner = 1 since there is only n-1 steps between n points.\n    1;\n  return `bandspace(${cardinality}, ${paddingInner}, ${paddingOuter}) * ${scaleName}_step`;\n}\n\n\n"]}},"error":null,"hash":"959884a851ecf31dc5886035c88f6edd","cacheData":{"env":{}}}