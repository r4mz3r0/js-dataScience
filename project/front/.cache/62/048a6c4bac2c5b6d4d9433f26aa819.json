{"id":"node_modules/vega-lite/build/src/compile/mark/mark.js","dependencies":[{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/mark.js.map","includedInParent":true,"mtime":499162500000},{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/package.json","includedInParent":true,"mtime":1593715260815},{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/package.json","includedInParent":true,"mtime":499162500000},{"name":"tslib","loc":{"line":3,"column":22},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/mark.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/tslib/tslib.es6.js"},{"name":"vega-util","loc":{"line":4,"column":26},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/mark.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-util/index.js"},{"name":"../../data","loc":{"line":5,"column":21},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/mark.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/data.js"},{"name":"../../encoding","loc":{"line":6,"column":25},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/mark.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/encoding.js"},{"name":"../../fielddef","loc":{"line":7,"column":25},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/mark.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/fielddef.js"},{"name":"../../mark","loc":{"line":8,"column":21},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/mark.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/mark.js"},{"name":"../../sort","loc":{"line":9,"column":21},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/mark.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/sort.js"},{"name":"../../util","loc":{"line":10,"column":21},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/mark.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/util.js"},{"name":"../common","loc":{"line":11,"column":23},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/mark.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/common.js"},{"name":"./area","loc":{"line":12,"column":21},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/mark.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/area.js"},{"name":"./bar","loc":{"line":13,"column":20},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/mark.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/bar.js"},{"name":"./geoshape","loc":{"line":14,"column":25},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/mark.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/geoshape.js"},{"name":"./line","loc":{"line":15,"column":21},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/mark.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/line.js"},{"name":"./point","loc":{"line":16,"column":22},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/mark.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/point.js"},{"name":"./rect","loc":{"line":17,"column":21},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/mark.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/rect.js"},{"name":"./rule","loc":{"line":18,"column":21},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/mark.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/rule.js"},{"name":"./text","loc":{"line":19,"column":21},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/mark.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/text.js"},{"name":"./tick","loc":{"line":20,"column":21},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/mark.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/tick.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar vega_util_1 = require(\"vega-util\");\nvar data_1 = require(\"../../data\");\nvar encoding_1 = require(\"../../encoding\");\nvar fielddef_1 = require(\"../../fielddef\");\nvar mark_1 = require(\"../../mark\");\nvar sort_1 = require(\"../../sort\");\nvar util_1 = require(\"../../util\");\nvar common_1 = require(\"../common\");\nvar area_1 = require(\"./area\");\nvar bar_1 = require(\"./bar\");\nvar geoshape_1 = require(\"./geoshape\");\nvar line_1 = require(\"./line\");\nvar point_1 = require(\"./point\");\nvar rect_1 = require(\"./rect\");\nvar rule_1 = require(\"./rule\");\nvar text_1 = require(\"./text\");\nvar tick_1 = require(\"./tick\");\nvar markCompiler = {\n    area: area_1.area,\n    bar: bar_1.bar,\n    circle: point_1.circle,\n    geoshape: geoshape_1.geoshape,\n    line: line_1.line,\n    point: point_1.point,\n    rect: rect_1.rect,\n    rule: rule_1.rule,\n    square: point_1.square,\n    text: text_1.text,\n    tick: tick_1.tick,\n    trail: line_1.trail\n};\nfunction parseMarkGroup(model) {\n    if (util_1.contains([mark_1.LINE, mark_1.AREA, mark_1.TRAIL], model.mark)) {\n        return parsePathMark(model);\n    }\n    else {\n        return getMarkGroups(model);\n    }\n}\nexports.parseMarkGroup = parseMarkGroup;\nvar FACETED_PATH_PREFIX = 'faceted_path_';\nfunction parsePathMark(model) {\n    var details = pathGroupingFields(model.mark, model.encoding);\n    var pathMarks = getMarkGroups(model, {\n        // If has subfacet for line/area group, need to use faceted data from below.\n        fromPrefix: (details.length > 0 ? FACETED_PATH_PREFIX : '')\n    });\n    if (details.length > 0) { // have level of details - need to facet line into subgroups\n        // TODO: for non-stacked plot, map order to zindex. (Maybe rename order for layer to zindex?)\n        return [{\n                name: model.getName('pathgroup'),\n                type: 'group',\n                from: {\n                    facet: {\n                        name: FACETED_PATH_PREFIX + model.requestDataName(data_1.MAIN),\n                        data: model.requestDataName(data_1.MAIN),\n                        groupby: details,\n                    }\n                },\n                encode: {\n                    update: {\n                        width: { field: { group: 'width' } },\n                        height: { field: { group: 'height' } }\n                    }\n                },\n                marks: pathMarks\n            }];\n    }\n    else {\n        return pathMarks;\n    }\n}\nfunction getSort(model) {\n    var encoding = model.encoding, stack = model.stack, mark = model.mark, markDef = model.markDef;\n    var order = encoding.order;\n    if (!vega_util_1.isArray(order) && fielddef_1.isValueDef(order)) {\n        return undefined;\n    }\n    else if ((vega_util_1.isArray(order) || fielddef_1.isFieldDef(order)) && !stack) {\n        // Sort by the order field if it is specified and the field is not stacked. (For stacked field, order specify stack order.)\n        return common_1.sortParams(order, { expr: 'datum' });\n    }\n    else if (mark_1.isPathMark(mark)) {\n        // For both line and area, we sort values based on dimension by default\n        var dimensionChannelDef = encoding[markDef.orient === 'horizontal' ? 'y' : 'x'];\n        if (fielddef_1.isFieldDef(dimensionChannelDef)) {\n            var s = dimensionChannelDef.sort;\n            var sortField = sort_1.isSortField(s) ?\n                fielddef_1.vgField({\n                    // FIXME: this op might not already exist?\n                    // FIXME: what if dimensionChannel (x or y) contains custom domain?\n                    aggregate: encoding_1.isAggregate(model.encoding) ? s.op : undefined,\n                    field: s.field\n                }, { expr: 'datum' }) :\n                fielddef_1.vgField(dimensionChannelDef, {\n                    // For stack with imputation, we only have bin_mid\n                    binSuffix: model.stack && model.stack.impute ? 'mid' : undefined,\n                    expr: 'datum'\n                });\n            return {\n                field: sortField,\n                order: 'descending'\n            };\n        }\n        return undefined;\n    }\n    return undefined;\n}\nexports.getSort = getSort;\nfunction getMarkGroups(model, opt) {\n    if (opt === void 0) { opt = { fromPrefix: '' }; }\n    var mark = model.mark;\n    var clip = model.markDef.clip !== undefined ?\n        !!model.markDef.clip : scaleClip(model);\n    var style = common_1.getStyles(model.markDef);\n    var key = model.encoding.key;\n    var sort = getSort(model);\n    var postEncodingTransform = markCompiler[mark].postEncodingTransform ? markCompiler[mark].postEncodingTransform(model) : null;\n    return [tslib_1.__assign({ name: model.getName('marks'), type: markCompiler[mark].vgMark }, (clip ? { clip: true } : {}), (style ? { style: style } : {}), (key ? { key: { field: key.field } } : {}), (sort ? { sort: sort } : {}), { from: { data: opt.fromPrefix + model.requestDataName(data_1.MAIN) }, encode: {\n                update: markCompiler[mark].encodeEntry(model)\n            } }, (postEncodingTransform ? {\n            transform: postEncodingTransform\n        } : {}))];\n}\n/**\n * Returns list of path grouping fields\n * that the model's spec contains.\n */\nfunction pathGroupingFields(mark, encoding) {\n    return util_1.keys(encoding).reduce(function (details, channel) {\n        switch (channel) {\n            // x, y, x2, y2, lat, long, lat1, long2, order, tooltip, href, cursor should not cause lines to group\n            case 'x':\n            case 'y':\n            case 'order':\n            case 'tooltip':\n            case 'href':\n            case 'x2':\n            case 'y2':\n            case 'latitude':\n            case 'longitude':\n            case 'latitude2':\n            case 'longitude2':\n            // TODO: case 'cursor':\n            // text, shape, shouldn't be a part of line/trail/area\n            case 'text':\n            case 'shape':\n                return details;\n            case 'detail':\n            case 'key':\n                var channelDef = encoding[channel];\n                if (channelDef) {\n                    (vega_util_1.isArray(channelDef) ? channelDef : [channelDef]).forEach(function (fieldDef) {\n                        if (!fieldDef.aggregate) {\n                            details.push(fielddef_1.vgField(fieldDef, {}));\n                        }\n                    });\n                }\n                return details;\n            case 'size':\n                if (mark === 'trail') {\n                    // For trail, size should not group trail lines.\n                    return details;\n                }\n            // For line, it should group lines.\n            /* tslint:disable */\n            // intentional fall through\n            case 'color':\n            case 'fill':\n            case 'stroke':\n            case 'opacity':\n                // TODO strokeDashOffset:\n                /* tslint:enable */\n                var fieldDef = fielddef_1.getFieldDef(encoding[channel]);\n                if (fieldDef && !fieldDef.aggregate) {\n                    details.push(fielddef_1.vgField(fieldDef, {}));\n                }\n                return details;\n            default:\n                throw new Error(\"Bug: Channel \" + channel + \" unimplemented for line mark\");\n        }\n    }, []);\n}\nexports.pathGroupingFields = pathGroupingFields;\n/**\n * If scales are bound to interval selections, we want to automatically clip\n * marks to account for panning/zooming interactions. We identify bound scales\n * by the domainRaw property, which gets added during scale parsing.\n */\nfunction scaleClip(model) {\n    var xScale = model.getScaleComponent('x');\n    var yScale = model.getScaleComponent('y');\n    return (xScale && xScale.get('domainRaw')) ||\n        (yScale && yScale.get('domainRaw')) ? true : false;\n}\n"},"sourceMaps":{"js":{"version":3,"file":"mark.js","sourceRoot":"","sources":["../../../../src/compile/mark/mark.ts"],"names":[],"mappings":"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","sourcesContent":["import {isArray} from 'vega-util';\nimport {MAIN} from '../../data';\nimport {Encoding, isAggregate} from '../../encoding';\nimport {getFieldDef, isFieldDef, isValueDef, vgField} from '../../fielddef';\nimport {AREA, isPathMark, LINE, Mark, TRAIL} from '../../mark';\nimport {isSortField} from '../../sort';\nimport {contains, keys} from '../../util';\nimport {getStyles, sortParams} from '../common';\nimport {UnitModel} from '../unit';\nimport {area} from './area';\nimport {bar} from './bar';\nimport {MarkCompiler} from './base';\nimport {geoshape} from './geoshape';\nimport {line, trail} from './line';\nimport {circle, point, square} from './point';\nimport {rect} from './rect';\nimport {rule} from './rule';\nimport {text} from './text';\nimport {tick} from './tick';\n\n\nconst markCompiler: {[m in Mark]: MarkCompiler} = {\n  area,\n  bar,\n  circle,\n  geoshape,\n  line,\n  point,\n  rect,\n  rule,\n  square,\n  text,\n  tick,\n  trail\n};\n\nexport function parseMarkGroup(model: UnitModel): any[] {\n  if (contains([LINE, AREA, TRAIL], model.mark)) {\n    return parsePathMark(model);\n  } else {\n    return getMarkGroups(model);\n  }\n}\n\nconst FACETED_PATH_PREFIX = 'faceted_path_';\n\nfunction parsePathMark(model: UnitModel) {\n  const details = pathGroupingFields(model.mark, model.encoding);\n\n  const pathMarks = getMarkGroups(model, {\n    // If has subfacet for line/area group, need to use faceted data from below.\n    fromPrefix: (details.length > 0 ? FACETED_PATH_PREFIX : '')\n  });\n\n  if (details.length > 0) { // have level of details - need to facet line into subgroups\n    // TODO: for non-stacked plot, map order to zindex. (Maybe rename order for layer to zindex?)\n\n    return [{\n      name: model.getName('pathgroup'),\n      type: 'group',\n      from: {\n        facet: {\n          name: FACETED_PATH_PREFIX + model.requestDataName(MAIN),\n          data: model.requestDataName(MAIN),\n          groupby: details,\n        }\n      },\n      encode: {\n        update: {\n          width: {field: {group: 'width'}},\n          height: {field: {group: 'height'}}\n        }\n      },\n      marks: pathMarks\n    }];\n  } else {\n    return pathMarks;\n  }\n}\n\nexport function getSort(model: UnitModel) {\n  const {encoding, stack, mark, markDef} = model;\n  const order = encoding.order;\n  if (!isArray(order) && isValueDef(order)) {\n    return undefined;\n  } else if ((isArray(order) || isFieldDef(order)) && !stack) {\n    // Sort by the order field if it is specified and the field is not stacked. (For stacked field, order specify stack order.)\n    return sortParams(order, {expr: 'datum'});\n  } else if (isPathMark(mark)) {\n    // For both line and area, we sort values based on dimension by default\n    const dimensionChannelDef = encoding[markDef.orient === 'horizontal' ? 'y' : 'x'];\n    if (isFieldDef(dimensionChannelDef)) {\n      const s = dimensionChannelDef.sort;\n      const sortField = isSortField(s) ?\n        vgField({\n          // FIXME: this op might not already exist?\n          // FIXME: what if dimensionChannel (x or y) contains custom domain?\n          aggregate: isAggregate(model.encoding) ? s.op : undefined,\n          field: s.field\n        }, {expr: 'datum'}) :\n        vgField(dimensionChannelDef, {\n          // For stack with imputation, we only have bin_mid\n          binSuffix: model.stack && model.stack.impute ? 'mid' : undefined,\n          expr: 'datum'\n        });\n\n      return {\n        field: sortField,\n        order: 'descending'\n      };\n    }\n    return undefined;\n  }\n  return undefined;\n}\n\nfunction getMarkGroups(model: UnitModel, opt: {\n  fromPrefix: string\n} = {fromPrefix: ''}) {\n  const mark = model.mark;\n\n  const clip = model.markDef.clip !== undefined ?\n    !!model.markDef.clip : scaleClip(model);\n  const style = getStyles(model.markDef);\n  const key = model.encoding.key;\n  const sort = getSort(model);\n\n  const postEncodingTransform = markCompiler[mark].postEncodingTransform ? markCompiler[mark].postEncodingTransform(model) : null;\n\n  return [{\n    name: model.getName('marks'),\n    type: markCompiler[mark].vgMark,\n    ...(clip ? {clip: true} : {}),\n    ...(style ? {style} : {}),\n    ...(key ? {key: {field: key.field}} : {}),\n    ...(sort ? {sort} : {}),\n    from: {data: opt.fromPrefix + model.requestDataName(MAIN)},\n    encode: {\n      update: markCompiler[mark].encodeEntry(model)\n    },\n    ...(postEncodingTransform ? {\n      transform: postEncodingTransform\n    } : {})\n  }];\n\n}\n\n/**\n * Returns list of path grouping fields\n * that the model's spec contains.\n */\nexport function pathGroupingFields(mark: Mark, encoding: Encoding<string>): string[] {\n  return keys(encoding).reduce((details, channel) => {\n    switch (channel) {\n      // x, y, x2, y2, lat, long, lat1, long2, order, tooltip, href, cursor should not cause lines to group\n      case 'x':\n      case 'y':\n      case 'order':\n      case 'tooltip':\n      case 'href':\n      case 'x2':\n      case 'y2':\n\n      case 'latitude':\n      case 'longitude':\n      case 'latitude2':\n      case 'longitude2':\n      // TODO: case 'cursor':\n\n      // text, shape, shouldn't be a part of line/trail/area\n      case 'text':\n      case 'shape':\n        return details;\n\n      case 'detail':\n      case 'key':\n        const channelDef = encoding[channel];\n        if (channelDef) {\n          (isArray(channelDef) ? channelDef : [channelDef]).forEach((fieldDef) => {\n            if (!fieldDef.aggregate) {\n              details.push(vgField(fieldDef, {}));\n            }\n          });\n        }\n        return details;\n\n      case 'size':\n        if (mark === 'trail') {\n          // For trail, size should not group trail lines.\n          return details;\n        }\n        // For line, it should group lines.\n\n      /* tslint:disable */\n      // intentional fall through\n\n      case 'color':\n      case 'fill':\n      case 'stroke':\n      case 'opacity':\n      // TODO strokeDashOffset:\n\n      /* tslint:enable */\n        const fieldDef = getFieldDef<string>(encoding[channel]);\n        if (fieldDef && !fieldDef.aggregate) {\n          details.push(vgField(fieldDef, {}));\n        }\n        return details;\n      default:\n        throw new Error(`Bug: Channel ${channel} unimplemented for line mark`);\n    }\n  }, []);\n}\n\n/**\n * If scales are bound to interval selections, we want to automatically clip\n * marks to account for panning/zooming interactions. We identify bound scales\n * by the domainRaw property, which gets added during scale parsing.\n */\nfunction scaleClip(model: UnitModel) {\n  const xScale = model.getScaleComponent('x');\n  const yScale = model.getScaleComponent('y');\n  return (xScale && xScale.get('domainRaw')) ||\n    (yScale && yScale.get('domainRaw')) ? true : false;\n}\n"]}},"error":null,"hash":"62bae6b6e74af0d8a15e5a5b51e3eb90","cacheData":{"env":{}}}