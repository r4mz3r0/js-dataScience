{"id":"node_modules/vega-lite/build/src/validate.js","dependencies":[{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/validate.js.map","includedInParent":true,"mtime":499162500000},{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/package.json","includedInParent":true,"mtime":1593715260815},{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/package.json","includedInParent":true,"mtime":499162500000},{"name":"vega-util","loc":{"line":3,"column":26},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/validate.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-util/index.js"},{"name":"./mark","loc":{"line":5,"column":21},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/validate.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/mark.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar vega_util_1 = require(\"vega-util\");\nvar mark_1 = require(\"./mark\");\nvar mark_2 = require(\"./mark\");\n/**\n * Required Encoding Channels for each mark type\n */\nexports.DEFAULT_REQUIRED_CHANNEL_MAP = {\n    text: ['text'],\n    line: ['x', 'y'],\n    trail: ['x', 'y'],\n    area: ['x', 'y']\n};\n/**\n * Supported Encoding Channel for each mark type\n */\nexports.DEFAULT_SUPPORTED_CHANNEL_TYPE = {\n    bar: vega_util_1.toSet(['row', 'column', 'x', 'y', 'size', 'color', 'fill', 'stroke', 'detail']),\n    line: vega_util_1.toSet(['row', 'column', 'x', 'y', 'color', 'fill', 'stroke', 'color', 'detail']),\n    trail: vega_util_1.toSet(['row', 'column', 'x', 'y', 'color', 'fill', 'stroke', 'color', 'detail', 'size']),\n    area: vega_util_1.toSet(['row', 'column', 'x', 'y', 'color', 'fill', 'stroke', 'detail']),\n    tick: vega_util_1.toSet(['row', 'column', 'x', 'y', 'color', 'fill', 'stroke', 'detail']),\n    circle: vega_util_1.toSet(['row', 'column', 'x', 'y', 'color', 'fill', 'stroke', 'size', 'detail']),\n    square: vega_util_1.toSet(['row', 'column', 'x', 'y', 'color', 'fill', 'stroke', 'size', 'detail']),\n    point: vega_util_1.toSet(['row', 'column', 'x', 'y', 'color', 'fill', 'stroke', 'size', 'detail', 'shape']),\n    geoshape: vega_util_1.toSet(['row', 'column', 'color', 'fill', 'stroke', 'detail', 'shape']),\n    text: vega_util_1.toSet(['row', 'column', 'size', 'color', 'fill', 'stroke', 'text']) // TODO(#724) revise\n};\n// TODO: consider if we should add validate method and\n// requires ZSchema in the main vega-lite repo\n/**\n * Further check if encoding mapping of a spec is invalid and\n * return error if it is invalid.\n *\n * This checks if\n * (1) all the required encoding channels for the mark type are specified\n * (2) all the specified encoding channels are supported by the mark type\n * @param  {[type]} spec [description]\n * @param  {RequiredChannelMap = DefaultRequiredChannelMap}  requiredChannelMap\n * @param  {SupportedChannelMap = DefaultSupportedChannelMap} supportedChannelMap\n * @return {String} Return one reason why the encoding is invalid,\n *                  or null if the encoding is valid.\n */\nfunction getEncodingMappingError(spec, requiredChannelMap, supportedChannelMap) {\n    if (requiredChannelMap === void 0) { requiredChannelMap = exports.DEFAULT_REQUIRED_CHANNEL_MAP; }\n    if (supportedChannelMap === void 0) { supportedChannelMap = exports.DEFAULT_SUPPORTED_CHANNEL_TYPE; }\n    var mark = mark_1.isMarkDef(spec.mark) ? spec.mark.type : spec.mark;\n    var encoding = spec.encoding;\n    var requiredChannels = requiredChannelMap[mark];\n    var supportedChannels = supportedChannelMap[mark];\n    for (var i in requiredChannels) { // all required channels are in encoding`\n        if (!(requiredChannels[i] in encoding)) {\n            return 'Missing encoding channel \\\"' + requiredChannels[i] +\n                '\\\" for mark \\\"' + mark + '\\\"';\n        }\n    }\n    for (var channel in encoding) { // all channels in encoding are supported\n        if (!supportedChannels[channel]) {\n            return 'Encoding channel \\\"' + channel +\n                '\\\" is not supported by mark type \\\"' + mark + '\\\"';\n        }\n    }\n    if (mark === mark_2.BAR && !encoding.x && !encoding.y) {\n        return 'Missing both x and y for bar';\n    }\n    return null;\n}\nexports.getEncodingMappingError = getEncodingMappingError;\n"},"sourceMaps":{"js":{"version":3,"file":"validate.js","sourceRoot":"","sources":["../../src/validate.ts"],"names":[],"mappings":"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","sourcesContent":["import {toSet} from 'vega-util';\nimport {isMarkDef} from './mark';\nimport {BAR} from './mark';\nimport {FacetedCompositeUnitSpec} from './spec';\n\n\n\n// TODO: move to vl.spec.validator?\nexport interface RequiredChannelMap {\n  [mark: string]: Array<string>;\n}\n\n/**\n * Required Encoding Channels for each mark type\n */\nexport const DEFAULT_REQUIRED_CHANNEL_MAP: RequiredChannelMap = {\n  text: ['text'],\n  line: ['x', 'y'],\n  trail: ['x', 'y'],\n  area: ['x', 'y']\n};\n\nexport interface SupportedChannelMap {\n  [mark: string]: {\n    [channel: string]: boolean\n  };\n}\n\n/**\n * Supported Encoding Channel for each mark type\n */\nexport const DEFAULT_SUPPORTED_CHANNEL_TYPE: SupportedChannelMap = {\n  bar: toSet(['row', 'column', 'x', 'y', 'size', 'color', 'fill', 'stroke', 'detail']),\n  line: toSet(['row', 'column', 'x', 'y', 'color', 'fill', 'stroke', 'color', 'detail']),\n  trail: toSet(['row', 'column', 'x', 'y', 'color', 'fill', 'stroke', 'color', 'detail', 'size']),\n  area: toSet(['row', 'column', 'x', 'y', 'color', 'fill', 'stroke', 'detail']),\n  tick: toSet(['row', 'column', 'x', 'y', 'color', 'fill', 'stroke', 'detail']),\n  circle: toSet(['row', 'column', 'x', 'y', 'color', 'fill', 'stroke', 'size', 'detail']),\n  square: toSet(['row', 'column', 'x', 'y', 'color', 'fill', 'stroke', 'size', 'detail']),\n  point: toSet(['row', 'column', 'x', 'y', 'color', 'fill', 'stroke', 'size', 'detail', 'shape']),\n  geoshape: toSet(['row', 'column', 'color', 'fill', 'stroke', 'detail', 'shape']),\n  text: toSet(['row', 'column', 'size', 'color', 'fill', 'stroke', 'text'])                         // TODO(#724) revise\n};\n\n// TODO: consider if we should add validate method and\n// requires ZSchema in the main vega-lite repo\n\n/**\n * Further check if encoding mapping of a spec is invalid and\n * return error if it is invalid.\n *\n * This checks if\n * (1) all the required encoding channels for the mark type are specified\n * (2) all the specified encoding channels are supported by the mark type\n * @param  {[type]} spec [description]\n * @param  {RequiredChannelMap = DefaultRequiredChannelMap}  requiredChannelMap\n * @param  {SupportedChannelMap = DefaultSupportedChannelMap} supportedChannelMap\n * @return {String} Return one reason why the encoding is invalid,\n *                  or null if the encoding is valid.\n */\nexport function getEncodingMappingError(spec: FacetedCompositeUnitSpec,\n  requiredChannelMap: RequiredChannelMap = DEFAULT_REQUIRED_CHANNEL_MAP,\n  supportedChannelMap: SupportedChannelMap = DEFAULT_SUPPORTED_CHANNEL_TYPE\n  ) {\n  const mark = isMarkDef(spec.mark) ? spec.mark.type : spec.mark;\n  const encoding = spec.encoding;\n  const requiredChannels = requiredChannelMap[mark];\n  const supportedChannels = supportedChannelMap[mark];\n\n  for (const i in requiredChannels) { // all required channels are in encoding`\n    if (!(requiredChannels[i] in encoding)) {\n      return 'Missing encoding channel \\\"' + requiredChannels[i] +\n        '\\\" for mark \\\"' + mark + '\\\"';\n    }\n  }\n\n  for (const channel in encoding) { // all channels in encoding are supported\n    if (!supportedChannels[channel]) {\n      return 'Encoding channel \\\"' + channel +\n        '\\\" is not supported by mark type \\\"' + mark + '\\\"';\n    }\n  }\n\n  if (mark === BAR && !encoding.x && !encoding.y) {\n    return 'Missing both x and y for bar';\n  }\n\n  return null;\n}\n"]}},"error":null,"hash":"fd1eac763bd605ed31f2915bf48cde0c","cacheData":{"env":{}}}