{"id":"node_modules/vega-lite/build/src/compile/data/index.js","dependencies":[{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/index.js.map","includedInParent":true,"mtime":499162500000},{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/package.json","includedInParent":true,"mtime":1593715260815},{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/package.json","includedInParent":true,"mtime":499162500000},{"name":"tslib","loc":{"line":3,"column":22},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/index.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/tslib/tslib.es6.js"},{"name":"../split","loc":{"line":4,"column":22},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/index.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/split.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar split_1 = require(\"../split\");\n/**\n * Class to track interesting properties (see https://15721.courses.cs.cmu.edu/spring2016/papers/graefe-ieee1995.pdf)\n * about how fields have been parsed or whether they have been derived in a transforms. We use this to not parse the\n * same field again (or differently).\n */\nvar AncestorParse = /** @class */ (function (_super) {\n    tslib_1.__extends(AncestorParse, _super);\n    function AncestorParse(explicit, implicit, parseNothing) {\n        if (explicit === void 0) { explicit = {}; }\n        if (implicit === void 0) { implicit = {}; }\n        if (parseNothing === void 0) { parseNothing = false; }\n        var _this = _super.call(this, explicit, implicit) || this;\n        _this.explicit = explicit;\n        _this.implicit = implicit;\n        _this.parseNothing = parseNothing;\n        return _this;\n    }\n    AncestorParse.prototype.clone = function () {\n        var clone = _super.prototype.clone.call(this);\n        clone.parseNothing = this.parseNothing;\n        return clone;\n    };\n    return AncestorParse;\n}(split_1.Split));\nexports.AncestorParse = AncestorParse;\n"},"sourceMaps":{"js":{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../src/compile/data/index.ts"],"names":[],"mappings":";;;AACA,kCAA+B;AAkD/B;;;;GAIG;AACH;IAAmC,yCAAmB;IACpD,uBACkB,QAAoC,EACpC,QAAoC,EAC7C,YAAoB;QAFX,yBAAA,EAAA,aAAoC;QACpC,yBAAA,EAAA,aAAoC;QAC7C,6BAAA,EAAA,oBAAoB;QAH7B,YAKE,kBAAM,QAAQ,EAAE,QAAQ,CAAC,SAC1B;QALiB,cAAQ,GAAR,QAAQ,CAA4B;QACpC,cAAQ,GAAR,QAAQ,CAA4B;QAC7C,kBAAY,GAAZ,YAAY,CAAQ;;IAG7B,CAAC;IAEM,6BAAK,GAAZ;QACE,IAAM,KAAK,GAAG,iBAAM,KAAK,WAAmB,CAAC;QAC7C,KAAK,CAAC,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC;QACvC,OAAO,KAAK,CAAC;IACf,CAAC;IACH,oBAAC;AAAD,CAAC,AAdD,CAAmC,aAAK,GAcvC;AAdY,sCAAa","sourcesContent":["import {Dict} from '../../util';\nimport {Split} from '../split';\nimport {OutputNode} from './dataflow';\nimport {FacetNode} from './facet';\nimport {SourceNode} from './source';\n\nexport interface DataComponent {\n  /**\n   * A dictionary of sources indexed by a hash.\n   */\n  sources: Dict<SourceNode>;\n\n  /**\n   * Registry of output nodes.\n   */\n  outputNodes: Dict<OutputNode | FacetNode>;\n\n  /**\n   * How often is an output node used. If it is not used, we don't need to\n   * instantiate it in the assemble step.\n   */\n  outputNodeRefCounts: Dict<number>;\n\n  /**\n   * The output node before aggregation.\n   */\n  raw?: OutputNode;\n\n  /**\n   * The main output node.\n   */\n  main?: OutputNode;\n\n  /**\n   * For facets, we store the reference to the root node.\n   */\n  facetRoot?: FacetNode;\n\n  /**\n   * True if the data for this model is faceted.\n   * A dataset is faceted if a parent model is a facet and no new dataset is\n   * defined (which would make the data unfaceted again).\n   */\n  isFaceted: boolean;\n\n  /**\n   * Parse properties passed down from ancestors. Helps us to keep track of what has been parsed or is derived.\n   */\n  ancestorParse?: AncestorParse;\n}\n\n/**\n * Class to track interesting properties (see https://15721.courses.cs.cmu.edu/spring2016/papers/graefe-ieee1995.pdf)\n * about how fields have been parsed or whether they have been derived in a transforms. We use this to not parse the\n * same field again (or differently).\n */\nexport class AncestorParse extends Split<Dict<string>> {\n  constructor(\n    public readonly explicit: Partial<Dict<string>> = {},\n    public readonly implicit: Partial<Dict<string>> = {},\n    public parseNothing = false\n  ) {\n    super(explicit, implicit);\n  }\n\n  public clone(): AncestorParse {\n    const clone = super.clone() as AncestorParse;\n    clone.parseNothing = this.parseNothing;\n    return clone;\n  }\n}\n"]}},"error":null,"hash":"015c6899441a79995958402e143034a8","cacheData":{"env":{}}}