{"id":"node_modules/vega-lite/build/src/compile/projection/parse.js","dependencies":[{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/projection/parse.js.map","includedInParent":true,"mtime":499162500000},{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/package.json","includedInParent":true,"mtime":1593715260815},{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/package.json","includedInParent":true,"mtime":499162500000},{"name":"tslib","loc":{"line":3,"column":22},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/projection/parse.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/tslib/tslib.es6.js"},{"name":"../../channel","loc":{"line":4,"column":24},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/projection/parse.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/channel.js"},{"name":"../../data","loc":{"line":5,"column":21},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/projection/parse.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/data.js"},{"name":"../../projection","loc":{"line":6,"column":27},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/projection/parse.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/projection.js"},{"name":"../../type","loc":{"line":7,"column":21},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/projection/parse.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/type.js"},{"name":"../../util","loc":{"line":8,"column":21},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/projection/parse.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/util.js"},{"name":"../model","loc":{"line":9,"column":22},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/projection/parse.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/model.js"},{"name":"./component","loc":{"line":10,"column":26},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/projection/parse.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/projection/component.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar channel_1 = require(\"../../channel\");\nvar data_1 = require(\"../../data\");\nvar projection_1 = require(\"../../projection\");\nvar type_1 = require(\"../../type\");\nvar util_1 = require(\"../../util\");\nvar model_1 = require(\"../model\");\nvar component_1 = require(\"./component\");\nfunction parseProjection(model) {\n    if (model_1.isUnitModel(model)) {\n        model.component.projection = parseUnitProjection(model);\n    }\n    else {\n        // because parse happens from leaves up (unit specs before layer spec),\n        // we can be sure that the above if statement has already occurred\n        // and therefore we have access to child.component.projection\n        // for each of model's children\n        model.component.projection = parseNonUnitProjections(model);\n    }\n}\nexports.parseProjection = parseProjection;\nfunction parseUnitProjection(model) {\n    var specifiedProjection = model.specifiedProjection, config = model.config, hasProjection = model.hasProjection;\n    if (hasProjection) {\n        var data_2 = [];\n        [[channel_1.LONGITUDE, channel_1.LATITUDE], [channel_1.LONGITUDE2, channel_1.LATITUDE2]].forEach(function (posssiblePair) {\n            if (model.channelHasField(posssiblePair[0]) || model.channelHasField(posssiblePair[1])) {\n                data_2.push({\n                    signal: model.getName(\"geojson_\" + data_2.length)\n                });\n            }\n        });\n        if (model.channelHasField(channel_1.SHAPE) && model.fieldDef(channel_1.SHAPE).type === type_1.GEOJSON) {\n            data_2.push({\n                signal: model.getName(\"geojson_\" + data_2.length)\n            });\n        }\n        if (data_2.length === 0) {\n            // main source is geojson, so we can just use that\n            data_2.push(model.requestDataName(data_1.MAIN));\n        }\n        return new component_1.ProjectionComponent(model.projectionName(true), tslib_1.__assign({}, (config.projection || {}), (specifiedProjection || {})), [model.getSizeSignalRef('width'), model.getSizeSignalRef('height')], data_2);\n    }\n    return undefined;\n}\nfunction mergeIfNoConflict(first, second) {\n    var allPropertiesShared = util_1.every(projection_1.PROJECTION_PROPERTIES, function (prop) {\n        // neither has the poperty\n        if (!first.explicit.hasOwnProperty(prop) &&\n            !second.explicit.hasOwnProperty(prop)) {\n            return true;\n        }\n        // both have property and an equal value for property\n        if (first.explicit.hasOwnProperty(prop) &&\n            second.explicit.hasOwnProperty(prop) &&\n            // some properties might be signals or objects and require hashing for comparison\n            util_1.stringify(first.get(prop)) === util_1.stringify(second.get(prop))) {\n            return true;\n        }\n        return false;\n    });\n    var size = util_1.stringify(first.size) === util_1.stringify(second.size);\n    if (size) {\n        if (allPropertiesShared) {\n            return first;\n        }\n        else if (util_1.stringify(first.explicit) === util_1.stringify({})) {\n            return second;\n        }\n        else if (util_1.stringify(second.explicit) === util_1.stringify({})) {\n            return first;\n        }\n    }\n    // if all properties don't match, let each unit spec have its own projection\n    return null;\n}\nfunction parseNonUnitProjections(model) {\n    if (model.children.length === 0) {\n        return undefined;\n    }\n    var nonUnitProjection;\n    var mergable = util_1.every(model.children, function (child) {\n        parseProjection(child);\n        var projection = child.component.projection;\n        if (!projection) {\n            // child layer does not use a projection\n            return true;\n        }\n        else if (!nonUnitProjection) {\n            // cached 'projection' is null, cache this one\n            nonUnitProjection = projection;\n            return true;\n        }\n        else {\n            var merge = mergeIfNoConflict(nonUnitProjection, projection);\n            if (merge) {\n                nonUnitProjection = merge;\n            }\n            return !!merge;\n        }\n    });\n    // it cached one and all other children share the same projection,\n    if (nonUnitProjection && mergable) {\n        // so we can elevate it to the layer level\n        var name_1 = model.projectionName(true);\n        var modelProjection_1 = new component_1.ProjectionComponent(name_1, nonUnitProjection.specifiedProjection, nonUnitProjection.size, util_1.duplicate(nonUnitProjection.data));\n        // rename and assign all others as merged\n        model.children.forEach(function (child) {\n            if (child.component.projection) {\n                modelProjection_1.data = modelProjection_1.data.concat(child.component.projection.data);\n                child.renameProjection(child.component.projection.get('name'), name_1);\n                child.component.projection.merged = true;\n            }\n        });\n        return modelProjection_1;\n    }\n    return undefined;\n}\n"},"sourceMaps":{"js":{"version":3,"file":"parse.js","sourceRoot":"","sources":["../../../../src/compile/projection/parse.ts"],"names":[],"mappings":";;;AAAA,yCAAgF;AAChF,mCAAgC;AAChC,+CAAuD;AACvD,mCAAmC;AACnC,mCAAuD;AAEvD,kCAA4C;AAE5C,yCAAgD;AAEhD,yBAAgC,KAAY;IAC1C,IAAI,mBAAW,CAAC,KAAK,CAAC,EAAE;QACtB,KAAK,CAAC,SAAS,CAAC,UAAU,GAAG,mBAAmB,CAAC,KAAK,CAAC,CAAC;KACzD;SAAM;QACL,uEAAuE;QACvE,kEAAkE;QAClE,6DAA6D;QAC7D,+BAA+B;QAC/B,KAAK,CAAC,SAAS,CAAC,UAAU,GAAG,uBAAuB,CAAC,KAAK,CAAC,CAAC;KAC7D;AACH,CAAC;AAVD,0CAUC;AAED,6BAA6B,KAAgB;IACpC,IAAA,+CAAmB,EAAE,qBAAM,EAAE,mCAAa,CAAU;IAE3D,IAAI,aAAa,EAAE;QACjB,IAAM,MAAI,GAA6B,EAAE,CAAC;QAE1C,CAAC,CAAC,mBAAS,EAAE,kBAAQ,CAAC,EAAE,CAAC,oBAAU,EAAE,mBAAS,CAAC,CAAC,CAAC,OAAO,CAAC,UAAC,aAAa;YACrE,IAAI,KAAK,CAAC,eAAe,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,eAAe,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,EAAE;gBACtF,MAAI,CAAC,IAAI,CAAC;oBACR,MAAM,EAAE,KAAK,CAAC,OAAO,CAAC,aAAW,MAAI,CAAC,MAAQ,CAAC;iBAChD,CAAC,CAAC;aACJ;QACH,CAAC,CAAC,CAAC;QAEH,IAAI,KAAK,CAAC,eAAe,CAAC,eAAK,CAAC,IAAI,KAAK,CAAC,QAAQ,CAAC,eAAK,CAAC,CAAC,IAAI,KAAK,cAAO,EAAE;YAC1E,MAAI,CAAC,IAAI,CAAC;gBACR,MAAM,EAAE,KAAK,CAAC,OAAO,CAAC,aAAW,MAAI,CAAC,MAAQ,CAAC;aAChD,CAAC,CAAC;SACJ;QAED,IAAI,MAAI,CAAC,MAAM,KAAK,CAAC,EAAE;YACrB,kDAAkD;YAClD,MAAI,CAAC,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,WAAI,CAAC,CAAC,CAAC;SACxC;QAED,OAAO,IAAI,+BAAmB,CAAC,KAAK,CAAC,cAAc,CAAC,IAAI,CAAC,uBACpD,CAAC,MAAM,CAAC,UAAU,IAAI,EAAE,CAAC,EACzB,CAAC,mBAAmB,IAAI,EAAE,CAAC,GAC7B,CAAC,KAAK,CAAC,gBAAgB,CAAC,OAAO,CAAC,EAAE,KAAK,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC,EAAE,MAAI,CAAC,CAAC;KAC/E;IAED,OAAO,SAAS,CAAC;AACnB,CAAC;AAGD,2BAA2B,KAA0B,EAAE,MAA2B;IAChF,IAAM,mBAAmB,GAAG,YAAK,CAAC,kCAAqB,EAAE,UAAC,IAAI;QAC5D,0BAA0B;QAC1B,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,cAAc,CAAC,IAAI,CAAC;YACtC,CAAC,MAAM,CAAC,QAAQ,CAAC,cAAc,CAAC,IAAI,CAAC,EAAE;YACvC,OAAO,IAAI,CAAC;SACb;QACD,qDAAqD;QACrD,IAAI,KAAK,CAAC,QAAQ,CAAC,cAAc,CAAC,IAAI,CAAC;YACrC,MAAM,CAAC,QAAQ,CAAC,cAAc,CAAC,IAAI,CAAC;YACpC,iFAAiF;YACjF,gBAAS,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,KAAK,gBAAS,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,EAAE;YAC5D,OAAO,IAAI,CAAC;SACb;QACD,OAAO,KAAK,CAAC;IACf,CAAC,CAAC,CAAC;IAEH,IAAM,IAAI,GAAG,gBAAS,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,gBAAS,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IAC9D,IAAI,IAAI,EAAE;QACR,IAAI,mBAAmB,EAAE;YACvB,OAAO,KAAK,CAAC;SACd;aAAM,IAAI,gBAAS,CAAC,KAAK,CAAC,QAAQ,CAAC,KAAK,gBAAS,CAAC,EAAE,CAAC,EAAE;YACtD,OAAO,MAAM,CAAC;SACf;aAAM,IAAI,gBAAS,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,gBAAS,CAAC,EAAE,CAAC,EAAE;YACvD,OAAO,KAAK,CAAC;SACd;KACF;IAED,4EAA4E;IAC5E,OAAO,IAAI,CAAC;AACd,CAAC;AAED,iCAAiC,KAAY;IAC3C,IAAI,KAAK,CAAC,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE;QAC/B,OAAO,SAAS,CAAC;KAClB;IAED,IAAI,iBAAsC,CAAC;IAC3C,IAAM,QAAQ,GAAG,YAAK,CAAC,KAAK,CAAC,QAAQ,EAAE,UAAC,KAAK;QAC3C,eAAe,CAAC,KAAK,CAAC,CAAC;QACvB,IAAM,UAAU,GAAG,KAAK,CAAC,SAAS,CAAC,UAAU,CAAC;QAC9C,IAAI,CAAC,UAAU,EAAE;YACf,wCAAwC;YACxC,OAAO,IAAI,CAAC;SACb;aAAM,IAAI,CAAC,iBAAiB,EAAE;YAC7B,8CAA8C;YAC9C,iBAAiB,GAAG,UAAU,CAAC;YAC/B,OAAO,IAAI,CAAC;SACb;aAAM;YACL,IAAM,KAAK,GAAG,iBAAiB,CAAC,iBAAiB,EAAE,UAAU,CAAC,CAAC;YAC/D,IAAI,KAAK,EAAE;gBACT,iBAAiB,GAAG,KAAK,CAAC;aAC3B;YACD,OAAO,CAAC,CAAC,KAAK,CAAC;SAChB;IACH,CAAC,CAAC,CAAC;IAEH,kEAAkE;IAClE,IAAI,iBAAiB,IAAI,QAAQ,EAAE;QACjC,0CAA0C;QAC1C,IAAM,MAAI,GAAG,KAAK,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;QACxC,IAAM,iBAAe,GAAG,IAAI,+BAAmB,CAC7C,MAAI,EACJ,iBAAiB,CAAC,mBAAmB,EACrC,iBAAiB,CAAC,IAAI,EACtB,gBAAS,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAClC,CAAC;QAEF,yCAAyC;QACzC,KAAK,CAAC,QAAQ,CAAC,OAAO,CAAC,UAAC,KAAK;YAC3B,IAAI,KAAK,CAAC,SAAS,CAAC,UAAU,EAAE;gBAC9B,iBAAe,CAAC,IAAI,GAAG,iBAAe,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;gBACpF,KAAK,CAAC,gBAAgB,CAAC,KAAK,CAAC,SAAS,CAAC,UAAU,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,MAAI,CAAC,CAAC;gBACrE,KAAK,CAAC,SAAS,CAAC,UAAU,CAAC,MAAM,GAAG,IAAI,CAAC;aAC1C;QACH,CAAC,CAAC,CAAC;QAEH,OAAO,iBAAe,CAAC;KACxB;IAED,OAAO,SAAS,CAAC;AACnB,CAAC","sourcesContent":["import {LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2, SHAPE} from '../../channel';\nimport {MAIN} from '../../data';\nimport {PROJECTION_PROPERTIES} from '../../projection';\nimport {GEOJSON} from '../../type';\nimport {duplicate, every, stringify} from '../../util';\nimport {VgSignalRef} from '../../vega.schema';\nimport {isUnitModel, Model} from '../model';\nimport {UnitModel} from '../unit';\nimport {ProjectionComponent} from './component';\n\nexport function parseProjection(model: Model) {\n  if (isUnitModel(model)) {\n    model.component.projection = parseUnitProjection(model);\n  } else {\n    // because parse happens from leaves up (unit specs before layer spec),\n    // we can be sure that the above if statement has already occurred\n    // and therefore we have access to child.component.projection\n    // for each of model's children\n    model.component.projection = parseNonUnitProjections(model);\n  }\n}\n\nfunction parseUnitProjection(model: UnitModel): ProjectionComponent {\n  const {specifiedProjection, config, hasProjection} = model;\n\n  if (hasProjection) {\n    const data: (VgSignalRef | string)[] = [];\n\n    [[LONGITUDE, LATITUDE], [LONGITUDE2, LATITUDE2]].forEach((posssiblePair) => {\n      if (model.channelHasField(posssiblePair[0]) || model.channelHasField(posssiblePair[1])) {\n        data.push({\n          signal: model.getName(`geojson_${data.length}`)\n        });\n      }\n    });\n\n    if (model.channelHasField(SHAPE) && model.fieldDef(SHAPE).type === GEOJSON) {\n      data.push({\n        signal: model.getName(`geojson_${data.length}`)\n      });\n    }\n\n    if (data.length === 0) {\n      // main source is geojson, so we can just use that\n      data.push(model.requestDataName(MAIN));\n    }\n\n    return new ProjectionComponent(model.projectionName(true), {\n      ...(config.projection || {}),\n      ...(specifiedProjection || {}),\n    }, [model.getSizeSignalRef('width'), model.getSizeSignalRef('height')], data);\n  }\n\n  return undefined;\n}\n\n\nfunction mergeIfNoConflict(first: ProjectionComponent, second: ProjectionComponent): ProjectionComponent {\n  const allPropertiesShared = every(PROJECTION_PROPERTIES, (prop) => {\n    // neither has the poperty\n    if (!first.explicit.hasOwnProperty(prop) &&\n      !second.explicit.hasOwnProperty(prop)) {\n      return true;\n    }\n    // both have property and an equal value for property\n    if (first.explicit.hasOwnProperty(prop) &&\n      second.explicit.hasOwnProperty(prop) &&\n      // some properties might be signals or objects and require hashing for comparison\n      stringify(first.get(prop)) === stringify(second.get(prop))) {\n      return true;\n    }\n    return false;\n  });\n\n  const size = stringify(first.size) === stringify(second.size);\n  if (size) {\n    if (allPropertiesShared) {\n      return first;\n    } else if (stringify(first.explicit) === stringify({})) {\n      return second;\n    } else if (stringify(second.explicit) === stringify({})) {\n      return first;\n    }\n  }\n\n  // if all properties don't match, let each unit spec have its own projection\n  return null;\n}\n\nfunction parseNonUnitProjections(model: Model): ProjectionComponent {\n  if (model.children.length === 0) {\n    return undefined;\n  }\n\n  let nonUnitProjection: ProjectionComponent;\n  const mergable = every(model.children, (child) => {\n    parseProjection(child);\n    const projection = child.component.projection;\n    if (!projection) {\n      // child layer does not use a projection\n      return true;\n    } else if (!nonUnitProjection) {\n      // cached 'projection' is null, cache this one\n      nonUnitProjection = projection;\n      return true;\n    } else {\n      const merge = mergeIfNoConflict(nonUnitProjection, projection);\n      if (merge) {\n        nonUnitProjection = merge;\n      }\n      return !!merge;\n    }\n  });\n\n  // it cached one and all other children share the same projection,\n  if (nonUnitProjection && mergable) {\n    // so we can elevate it to the layer level\n    const name = model.projectionName(true);\n    const modelProjection = new ProjectionComponent(\n      name,\n      nonUnitProjection.specifiedProjection,\n      nonUnitProjection.size,\n      duplicate(nonUnitProjection.data)\n    );\n\n    // rename and assign all others as merged\n    model.children.forEach((child) => {\n      if (child.component.projection) {\n        modelProjection.data = modelProjection.data.concat(child.component.projection.data);\n        child.renameProjection(child.component.projection.get('name'), name);\n        child.component.projection.merged = true;\n      }\n    });\n\n    return modelProjection;\n  }\n\n  return undefined;\n}\n"]}},"error":null,"hash":"fd2eb61e2a83ee95257ec5681d271581","cacheData":{"env":{}}}