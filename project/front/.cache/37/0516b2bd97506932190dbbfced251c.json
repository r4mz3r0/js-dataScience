{"id":"node_modules/vega-lite/build/src/compile/data/calculate.js","dependencies":[{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/calculate.js.map","includedInParent":true,"mtime":499162500000},{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/package.json","includedInParent":true,"mtime":1593715260815},{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/package.json","includedInParent":true,"mtime":499162500000},{"name":"tslib","loc":{"line":3,"column":22},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/calculate.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/tslib/tslib.es6.js"},{"name":"../../fielddef","loc":{"line":4,"column":25},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/calculate.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/fielddef.js"},{"name":"../../predicate","loc":{"line":5,"column":26},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/calculate.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/predicate.js"},{"name":"../../sort","loc":{"line":6,"column":21},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/calculate.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/sort.js"},{"name":"../../util","loc":{"line":7,"column":21},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/calculate.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/util.js"},{"name":"./dataflow","loc":{"line":8,"column":25},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/calculate.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/dataflow.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar fielddef_1 = require(\"../../fielddef\");\nvar predicate_1 = require(\"../../predicate\");\nvar sort_1 = require(\"../../sort\");\nvar util_1 = require(\"../../util\");\nvar dataflow_1 = require(\"./dataflow\");\n/**\n * We don't know what a calculate node depends on so we should never move it beyond anything that produces fields.\n */\nvar CalculateNode = /** @class */ (function (_super) {\n    tslib_1.__extends(CalculateNode, _super);\n    function CalculateNode(parent, transform) {\n        var _this = _super.call(this, parent) || this;\n        _this.transform = transform;\n        return _this;\n    }\n    CalculateNode.prototype.clone = function () {\n        return new CalculateNode(null, util_1.duplicate(this.transform));\n    };\n    CalculateNode.parseAllForSortIndex = function (parent, model) {\n        // get all the encoding with sort fields from model\n        model.forEachFieldDef(function (fieldDef, channel) {\n            if (!fielddef_1.isScaleFieldDef(fieldDef)) {\n                return;\n            }\n            if (sort_1.isSortArray(fieldDef.sort)) {\n                var field_1 = fieldDef.field, timeUnit_1 = fieldDef.timeUnit;\n                var sort = fieldDef.sort;\n                // generate `datum[\"a\"] === val0 ? 0 : datum[\"a\"] === val1 ? 1 : ... : n` via FieldEqualPredicate\n                var calculate = sort.map(function (sortValue, i) {\n                    return predicate_1.fieldFilterExpression({ field: field_1, timeUnit: timeUnit_1, equal: sortValue }) + \" ? \" + i + \" : \";\n                }).join('') + sort.length;\n                parent = new CalculateNode(parent, {\n                    calculate: calculate,\n                    as: sortArrayIndexField(fieldDef, channel)\n                });\n            }\n        });\n        return parent;\n    };\n    CalculateNode.prototype.producedFields = function () {\n        var out = {};\n        out[this.transform.as] = true;\n        return out;\n    };\n    CalculateNode.prototype.assemble = function () {\n        return {\n            type: 'formula',\n            expr: this.transform.calculate,\n            as: this.transform.as\n        };\n    };\n    return CalculateNode;\n}(dataflow_1.DataFlowNode));\nexports.CalculateNode = CalculateNode;\nfunction sortArrayIndexField(fieldDef, channel, expr) {\n    return fielddef_1.vgField(fieldDef, { prefix: channel, suffix: 'sort_index', expr: expr });\n}\nexports.sortArrayIndexField = sortArrayIndexField;\n"},"sourceMaps":{"js":{"version":3,"file":"calculate.js","sourceRoot":"","sources":["../../../../src/compile/data/calculate.ts"],"names":[],"mappings":";;;AACA,2CAAkE;AAClE,6CAAsD;AACtD,mCAAuC;AACvC,mCAAqC;AAKrC,uCAAwC;AAExC;;GAEG;AACH;IAAmC,yCAAY;IAK7C,uBAAY,MAAoB,EAAU,SAA6B;QAAvE,YACE,kBAAM,MAAM,CAAC,SACd;QAFyC,eAAS,GAAT,SAAS,CAAoB;;IAEvE,CAAC;IANM,6BAAK,GAAZ;QACE,OAAO,IAAI,aAAa,CAAC,IAAI,EAAE,gBAAS,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;IAC5D,CAAC;IAMa,kCAAoB,GAAlC,UAAmC,MAAoB,EAAE,KAAqB;QAC5E,mDAAmD;QACnD,KAAK,CAAC,eAAe,CAAC,UAAC,QAA0B,EAAE,OAAyB;YAC1E,IAAI,CAAC,0BAAe,CAAC,QAAQ,CAAC,EAAE;gBAC9B,OAAO;aACR;YACD,IAAI,kBAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;gBACvB,IAAA,wBAAK,EAAE,8BAAQ,CAAa;gBACnC,IAAM,IAAI,GAA6C,QAAQ,CAAC,IAAI,CAAC;gBACrE,iGAAiG;gBACjG,IAAM,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,UAAC,SAAS,EAAE,CAAC;oBACtC,OAAU,iCAAqB,CAAC,EAAC,KAAK,SAAA,EAAE,QAAQ,YAAA,EAAE,KAAK,EAAE,SAAS,EAAC,CAAC,WAAM,CAAC,QAAK,CAAC;gBACnF,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC;gBAE1B,MAAM,GAAG,IAAI,aAAa,CAAC,MAAM,EAAE;oBACjC,SAAS,WAAA;oBACT,EAAE,EAAE,mBAAmB,CAAC,QAAQ,EAAE,OAAO,CAAC;iBAC3C,CAAC,CAAC;aACJ;QACH,CAAC,CAAC,CAAC;QACH,OAAO,MAAM,CAAC;IAChB,CAAC;IAEM,sCAAc,GAArB;QACE,IAAM,GAAG,GAAG,EAAE,CAAC;QACf,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC;QAC9B,OAAO,GAAG,CAAC;IACb,CAAC;IAEM,gCAAQ,GAAf;QACE,OAAO;YACL,IAAI,EAAE,SAAS;YACf,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,SAAS;YAC9B,EAAE,EAAE,IAAI,CAAC,SAAS,CAAC,EAAE;SACtB,CAAC;IACJ,CAAC;IACH,oBAAC;AAAD,CAAC,AA7CD,CAAmC,uBAAY,GA6C9C;AA7CY,sCAAa;AA+C1B,6BAAoC,QAA0B,EAAE,OAAyB,EAAE,IAAc;IACvG,OAAO,kBAAO,CAAC,QAAQ,EAAE,EAAC,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,YAAY,EAAE,IAAI,MAAA,EAAC,CAAC,CAAC;AAC1E,CAAC;AAFD,kDAEC","sourcesContent":["import {DateTime} from '../../datetime';\nimport {FieldDef, isScaleFieldDef, vgField} from '../../fielddef';\nimport {fieldFilterExpression} from '../../predicate';\nimport {isSortArray} from '../../sort';\nimport {duplicate} from '../../util';\nimport {VgFormulaTransform} from '../../vega.schema';\nimport {ModelWithField} from '../model';\nimport {SingleDefChannel} from './../../channel';\nimport {CalculateTransform} from './../../transform';\nimport {DataFlowNode} from './dataflow';\n\n/**\n * We don't know what a calculate node depends on so we should never move it beyond anything that produces fields.\n */\nexport class CalculateNode extends DataFlowNode {\n  public clone() {\n    return new CalculateNode(null, duplicate(this.transform));\n  }\n\n  constructor(parent: DataFlowNode, private transform: CalculateTransform) {\n    super(parent);\n  }\n\n  public static parseAllForSortIndex(parent: DataFlowNode, model: ModelWithField) {\n    // get all the encoding with sort fields from model\n    model.forEachFieldDef((fieldDef: FieldDef<string>, channel: SingleDefChannel) => {\n      if (!isScaleFieldDef(fieldDef)) {\n        return;\n      }\n      if (isSortArray(fieldDef.sort)) {\n        const {field, timeUnit} = fieldDef;\n        const sort: (number | string | boolean | DateTime)[] = fieldDef.sort;\n        // generate `datum[\"a\"] === val0 ? 0 : datum[\"a\"] === val1 ? 1 : ... : n` via FieldEqualPredicate\n        const calculate = sort.map((sortValue, i) => {\n          return `${fieldFilterExpression({field, timeUnit, equal: sortValue})} ? ${i} : `;\n        }).join('') + sort.length;\n\n        parent = new CalculateNode(parent, {\n          calculate,\n          as: sortArrayIndexField(fieldDef, channel)\n        });\n      }\n    });\n    return parent;\n  }\n\n  public producedFields() {\n    const out = {};\n    out[this.transform.as] = true;\n    return out;\n  }\n\n  public assemble(): VgFormulaTransform {\n    return {\n      type: 'formula',\n      expr: this.transform.calculate,\n      as: this.transform.as\n    };\n  }\n}\n\nexport function sortArrayIndexField(fieldDef: FieldDef<string>, channel: SingleDefChannel, expr?: 'datum') {\n  return vgField(fieldDef, {prefix: channel, suffix: 'sort_index', expr});\n}\n"]}},"error":null,"hash":"e61dcdfc4eee65ba7eaa7e91af10c0f2","cacheData":{"env":{}}}