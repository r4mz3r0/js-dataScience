{"id":"node_modules/vega-lite/build/src/compile/scale/assemble.js","dependencies":[{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/scale/assemble.js.map","includedInParent":true,"mtime":499162500000},{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/package.json","includedInParent":true,"mtime":1593715260815},{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/package.json","includedInParent":true,"mtime":499162500000},{"name":"tslib","loc":{"line":3,"column":22},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/scale/assemble.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/tslib/tslib.es6.js"},{"name":"vega-util","loc":{"line":4,"column":26},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/scale/assemble.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-util/index.js"},{"name":"../../util","loc":{"line":5,"column":21},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/scale/assemble.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/util.js"},{"name":"../../vega.schema","loc":{"line":6,"column":28},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/scale/assemble.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/vega.schema.js"},{"name":"../model","loc":{"line":7,"column":22},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/scale/assemble.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/model.js"},{"name":"../selection/selection","loc":{"line":8,"column":26},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/scale/assemble.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/selection/selection.js"},{"name":"./domain","loc":{"line":9,"column":23},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/scale/assemble.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/scale/domain.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar vega_util_1 = require(\"vega-util\");\nvar util_1 = require(\"../../util\");\nvar vega_schema_1 = require(\"../../vega.schema\");\nvar model_1 = require(\"../model\");\nvar selection_1 = require(\"../selection/selection\");\nvar domain_1 = require(\"./domain\");\nfunction assembleScales(model) {\n    if (model_1.isLayerModel(model) || model_1.isConcatModel(model) || model_1.isRepeatModel(model)) {\n        // For concat / layer / repeat, include scales of children too\n        return model.children.reduce(function (scales, child) {\n            return scales.concat(assembleScales(child));\n        }, assembleScalesForModel(model));\n    }\n    else {\n        // For facet, child scales would not be included in the parent's scope.\n        // For unit, there is no child.\n        return assembleScalesForModel(model);\n    }\n}\nexports.assembleScales = assembleScales;\nfunction assembleScalesForModel(model) {\n    return util_1.keys(model.component.scales).reduce(function (scales, channel) {\n        var scaleComponent = model.component.scales[channel];\n        if (scaleComponent.merged) {\n            // Skipped merged scales\n            return scales;\n        }\n        var scale = scaleComponent.combine();\n        // need to separate const and non const object destruction\n        var domainRaw = scale.domainRaw, range = scale.range;\n        var name = scale.name, type = scale.type, _d = scale.domainRaw, _r = scale.range, otherScaleProps = tslib_1.__rest(scale, [\"name\", \"type\", \"domainRaw\", \"range\"]);\n        range = assembleScaleRange(range, name, model, channel);\n        // As scale parsing occurs before selection parsing, a temporary signal\n        // is used for domainRaw. Here, we detect if this temporary signal\n        // is set, and replace it with the correct domainRaw signal.\n        // For more information, see isRawSelectionDomain in selection.ts.\n        if (domainRaw && selection_1.isRawSelectionDomain(domainRaw)) {\n            domainRaw = selection_1.selectionScaleDomain(model, domainRaw);\n        }\n        scales.push(tslib_1.__assign({ name: name,\n            type: type, domain: domain_1.assembleDomain(model, channel) }, (domainRaw ? { domainRaw: domainRaw } : {}), { range: range }, otherScaleProps));\n        return scales;\n    }, []);\n}\nexports.assembleScalesForModel = assembleScalesForModel;\nfunction assembleScaleRange(scaleRange, scaleName, model, channel) {\n    // add signals to x/y range\n    if (channel === 'x' || channel === 'y') {\n        if (vega_schema_1.isVgRangeStep(scaleRange)) {\n            // For x/y range step, use a signal created in layout assemble instead of a constant range step.\n            return {\n                step: { signal: scaleName + '_step' }\n            };\n        }\n        else if (vega_util_1.isArray(scaleRange) && scaleRange.length === 2) {\n            var r0 = scaleRange[0];\n            var r1 = scaleRange[1];\n            if (r0 === 0 && vega_schema_1.isVgSignalRef(r1)) {\n                // Replace width signal just in case it is renamed.\n                return [0, { signal: model.getSizeName(r1.signal) }];\n            }\n            else if (vega_schema_1.isVgSignalRef(r0) && r1 === 0) {\n                // Replace height signal just in case it is renamed.\n                return [{ signal: model.getSizeName(r0.signal) }, 0];\n            }\n        }\n    }\n    return scaleRange;\n}\nexports.assembleScaleRange = assembleScaleRange;\n"},"sourceMaps":{"js":{"version":3,"file":"assemble.js","sourceRoot":"","sources":["../../../../src/compile/scale/assemble.ts"],"names":[],"mappings":";;;AAAA,uCAAkC;AAElC,mCAAgC;AAChC,iDAAiF;AACjF,kCAA2E;AAC3E,oDAAkF;AAClF,mCAAwC;AAExC,wBAA+B,KAAY;IACzC,IAAI,oBAAY,CAAC,KAAK,CAAC,IAAI,qBAAa,CAAC,KAAK,CAAC,IAAI,qBAAa,CAAC,KAAK,CAAC,EAAE;QACvE,8DAA8D;QAC9D,OAAO,KAAK,CAAC,QAAQ,CAAC,MAAM,CAAC,UAAC,MAAM,EAAE,KAAK;YACzC,OAAO,MAAM,CAAC,MAAM,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,CAAC;QAC9C,CAAC,EAAE,sBAAsB,CAAC,KAAK,CAAC,CAAC,CAAC;KACnC;SAAM;QACL,uEAAuE;QACvE,+BAA+B;QAC/B,OAAO,sBAAsB,CAAC,KAAK,CAAC,CAAC;KACtC;AACH,CAAC;AAXD,wCAWC;AAED,gCAAuC,KAAY;IAC/C,OAAO,WAAI,CAAC,KAAK,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,UAAC,MAAiB,EAAE,OAAqB;QAClF,IAAM,cAAc,GAAG,KAAK,CAAC,SAAS,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;QACvD,IAAI,cAAc,CAAC,MAAM,EAAE;YACzB,wBAAwB;YACxB,OAAO,MAAM,CAAC;SACf;QAED,IAAM,KAAK,GAAG,cAAc,CAAC,OAAO,EAAE,CAAC;QAEvC,0DAA0D;QACrD,IAAA,2BAAS,EAAE,mBAAK,CAAU;QACxB,IAAA,iBAAI,EAAE,iBAAI,EAAE,oBAAa,EAAE,gBAAS,EAAE,+EAAkB,CAAU;QAEzE,KAAK,GAAG,kBAAkB,CAAC,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;QAExD,uEAAuE;QACvE,kEAAkE;QAClE,4DAA4D;QAC5D,kEAAkE;QAClE,IAAI,SAAS,IAAI,gCAAoB,CAAC,SAAS,CAAC,EAAE;YAChD,SAAS,GAAG,gCAAoB,CAAC,KAAK,EAAE,SAAS,CAAC,CAAC;SACpD;QAGD,MAAM,CAAC,IAAI,oBACT,IAAI,MAAA;YACJ,IAAI,MAAA,EACJ,MAAM,EAAE,uBAAc,CAAC,KAAK,EAAE,OAAO,CAAC,IACnC,CAAC,SAAS,CAAC,CAAC,CAAC,EAAC,SAAS,WAAA,EAAC,CAAC,CAAC,CAAC,EAAE,CAAC,IACjC,KAAK,EAAE,KAAK,IACT,eAAe,EAClB,CAAC;QAEH,OAAO,MAAM,CAAC;IAChB,CAAC,EAAE,EAAe,CAAC,CAAC;AACxB,CAAC;AApCD,wDAoCC;AAED,4BAAmC,UAAmB,EAAE,SAAiB,EAAE,KAAY,EAAE,OAAgB;IACvG,2BAA2B;IAC3B,IAAI,OAAO,KAAK,GAAG,IAAI,OAAO,KAAK,GAAG,EAAE;QACtC,IAAI,2BAAa,CAAC,UAAU,CAAC,EAAE;YAC7B,gGAAgG;YAChG,OAAO;gBACL,IAAI,EAAE,EAAC,MAAM,EAAE,SAAS,GAAG,OAAO,EAAC;aACpC,CAAC;SACH;aAAM,IAAI,mBAAO,CAAC,UAAU,CAAC,IAAI,UAAU,CAAC,MAAM,KAAK,CAAC,EAAE;YACzD,IAAM,EAAE,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;YACzB,IAAM,EAAE,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;YACzB,IAAI,EAAE,KAAK,CAAC,IAAI,2BAAa,CAAC,EAAE,CAAC,EAAE;gBACjC,mDAAmD;gBACnD,OAAO,CAAC,CAAC,EAAE,EAAC,MAAM,EAAE,KAAK,CAAC,WAAW,CAAC,EAAE,CAAC,MAAM,CAAC,EAAC,CAAC,CAAC;aACpD;iBAAM,IAAI,2BAAa,CAAC,EAAE,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE;gBACxC,oDAAoD;gBACpD,OAAO,CAAC,EAAC,MAAM,EAAE,KAAK,CAAC,WAAW,CAAC,EAAE,CAAC,MAAM,CAAC,EAAC,EAAE,CAAC,CAAC,CAAC;aACpD;SACF;KACF;IACD,OAAO,UAAU,CAAC;AACpB,CAAC;AArBD,gDAqBC","sourcesContent":["import {isArray} from 'vega-util';\nimport {Channel, ScaleChannel} from '../../channel';\nimport {keys} from '../../util';\nimport {isVgRangeStep, isVgSignalRef, VgRange, VgScale} from '../../vega.schema';\nimport {isConcatModel, isLayerModel, isRepeatModel, Model} from '../model';\nimport {isRawSelectionDomain, selectionScaleDomain} from '../selection/selection';\nimport {assembleDomain} from './domain';\n\nexport function assembleScales(model: Model): VgScale[] {\n  if (isLayerModel(model) || isConcatModel(model) || isRepeatModel(model)) {\n    // For concat / layer / repeat, include scales of children too\n    return model.children.reduce((scales, child) => {\n      return scales.concat(assembleScales(child));\n    }, assembleScalesForModel(model));\n  } else {\n    // For facet, child scales would not be included in the parent's scope.\n    // For unit, there is no child.\n    return assembleScalesForModel(model);\n  }\n}\n\nexport function assembleScalesForModel(model: Model): VgScale[] {\n    return keys(model.component.scales).reduce((scales: VgScale[], channel: ScaleChannel) => {\n      const scaleComponent = model.component.scales[channel];\n      if (scaleComponent.merged) {\n        // Skipped merged scales\n        return scales;\n      }\n\n      const scale = scaleComponent.combine();\n\n      // need to separate const and non const object destruction\n      let {domainRaw, range} = scale;\n      const {name, type, domainRaw: _d, range: _r, ...otherScaleProps} = scale;\n\n      range = assembleScaleRange(range, name, model, channel);\n\n      // As scale parsing occurs before selection parsing, a temporary signal\n      // is used for domainRaw. Here, we detect if this temporary signal\n      // is set, and replace it with the correct domainRaw signal.\n      // For more information, see isRawSelectionDomain in selection.ts.\n      if (domainRaw && isRawSelectionDomain(domainRaw)) {\n        domainRaw = selectionScaleDomain(model, domainRaw);\n      }\n\n\n      scales.push({\n        name,\n        type,\n        domain: assembleDomain(model, channel),\n        ...(domainRaw ? {domainRaw} : {}),\n        range: range,\n        ...otherScaleProps\n      });\n\n      return scales;\n    }, [] as VgScale[]);\n}\n\nexport function assembleScaleRange(scaleRange: VgRange, scaleName: string, model: Model, channel: Channel) {\n  // add signals to x/y range\n  if (channel === 'x' || channel === 'y') {\n    if (isVgRangeStep(scaleRange)) {\n      // For x/y range step, use a signal created in layout assemble instead of a constant range step.\n      return {\n        step: {signal: scaleName + '_step'}\n      };\n    } else if (isArray(scaleRange) && scaleRange.length === 2) {\n      const r0 = scaleRange[0];\n      const r1 = scaleRange[1];\n      if (r0 === 0 && isVgSignalRef(r1)) {\n        // Replace width signal just in case it is renamed.\n        return [0, {signal: model.getSizeName(r1.signal)}];\n      } else if (isVgSignalRef(r0) && r1 === 0) {\n        // Replace height signal just in case it is renamed.\n        return [{signal: model.getSizeName(r0.signal)}, 0];\n      }\n    }\n  }\n  return scaleRange;\n}\n"]}},"error":null,"hash":"3f908265e35b11f5905766e2857d4066","cacheData":{"env":{}}}