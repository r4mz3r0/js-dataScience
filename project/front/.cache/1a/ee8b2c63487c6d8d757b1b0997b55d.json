{"id":"node_modules/vega-lite/build/src/compile/axis/properties.js","dependencies":[{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/axis/properties.js.map","includedInParent":true,"mtime":499162500000},{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/package.json","includedInParent":true,"mtime":1593715260815},{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/package.json","includedInParent":true,"mtime":499162500000},{"name":"tslib","loc":{"line":3,"column":22},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/axis/properties.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/tslib/tslib.es6.js"},{"name":"vega-util","loc":{"line":4,"column":26},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/axis/properties.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-util/index.js"},{"name":"../../bin","loc":{"line":5,"column":20},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/axis/properties.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/bin.js"},{"name":"../../channel","loc":{"line":6,"column":24},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/axis/properties.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/channel.js"},{"name":"../../fielddef","loc":{"line":7,"column":25},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/axis/properties.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/fielddef.js"},{"name":"../../log","loc":{"line":8,"column":39},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/axis/properties.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/log.js"},{"name":"../../scale","loc":{"line":9,"column":22},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/axis/properties.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/scale.js"},{"name":"../../type","loc":{"line":10,"column":21},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/axis/properties.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/type.js"},{"name":"../../util","loc":{"line":11,"column":21},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/axis/properties.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/util.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar vega_util_1 = require(\"vega-util\");\nvar bin_1 = require(\"../../bin\");\nvar channel_1 = require(\"../../channel\");\nvar fielddef_1 = require(\"../../fielddef\");\nvar log = tslib_1.__importStar(require(\"../../log\"));\nvar scale_1 = require(\"../../scale\");\nvar type_1 = require(\"../../type\");\nvar util_1 = require(\"../../util\");\n// TODO: we need to refactor this method after we take care of config refactoring\n/**\n * Default rules for whether to show a grid should be shown for a channel.\n * If `grid` is unspecified, the default value is `true` for ordinal scales that are not binned\n */\nfunction grid(scaleType, fieldDef) {\n    return !scale_1.hasDiscreteDomain(scaleType) && !fieldDef.bin;\n}\nexports.grid = grid;\nfunction gridScale(model, channel) {\n    var gridChannel = channel === 'x' ? 'y' : 'x';\n    if (model.getScaleComponent(gridChannel)) {\n        return model.scaleName(gridChannel);\n    }\n    return undefined;\n}\nexports.gridScale = gridScale;\nfunction labelFlush(fieldDef, channel, specifiedAxis) {\n    if (specifiedAxis.labelFlush !== undefined) {\n        return specifiedAxis.labelFlush;\n    }\n    if (channel === 'x' && util_1.contains(['quantitative', 'temporal'], fieldDef.type)) {\n        return true;\n    }\n    return undefined;\n}\nexports.labelFlush = labelFlush;\nfunction labelOverlap(fieldDef, specifiedAxis, channel, scaleType) {\n    if (specifiedAxis.labelOverlap !== undefined) {\n        return specifiedAxis.labelOverlap;\n    }\n    // do not prevent overlap for nominal data because there is no way to infer what the missing labels are\n    if (fieldDef.type !== 'nominal') {\n        if (scaleType === 'log') {\n            return 'greedy';\n        }\n        return true;\n    }\n    return undefined;\n}\nexports.labelOverlap = labelOverlap;\nfunction orient(channel) {\n    switch (channel) {\n        case channel_1.X:\n            return 'bottom';\n        case channel_1.Y:\n            return 'left';\n    }\n    /* istanbul ignore next: This should never happen. */\n    throw new Error(log.message.INVALID_CHANNEL_FOR_AXIS);\n}\nexports.orient = orient;\nfunction tickCount(channel, fieldDef, scaleType, size) {\n    if (!scale_1.hasDiscreteDomain(scaleType) && scaleType !== 'log' && !util_1.contains(['month', 'hours', 'day', 'quarter'], fieldDef.timeUnit)) {\n        if (fieldDef.bin) {\n            // for binned data, we don't want more ticks than maxbins\n            return { signal: \"ceil(\" + size.signal + \"/20)\" };\n        }\n        return { signal: \"ceil(\" + size.signal + \"/40)\" };\n    }\n    return undefined;\n}\nexports.tickCount = tickCount;\nfunction title(maxLength, fieldDef, config) {\n    // if not defined, automatically determine axis title from field def\n    var fieldTitle = fielddef_1.title(fieldDef, config);\n    return maxLength ? vega_util_1.truncate(fieldTitle, maxLength) : fieldTitle;\n}\nexports.title = title;\nfunction values(specifiedAxis, model, fieldDef, channel) {\n    var vals = specifiedAxis.values;\n    if (vals) {\n        return fielddef_1.valueArray(fieldDef, vals);\n    }\n    if (fieldDef.bin && fieldDef.type === type_1.QUANTITATIVE) {\n        var domain = model.scaleDomain(channel);\n        if (domain && domain !== 'unaggregated' && !scale_1.isSelectionDomain(domain)) { // explicit value\n            return undefined;\n        }\n        var signal = model.getName(bin_1.binToString(fieldDef.bin) + \"_\" + fieldDef.field + \"_bins\");\n        return { signal: \"sequence(\" + signal + \".start, \" + signal + \".stop + \" + signal + \".step, \" + signal + \".step)\" };\n    }\n    return undefined;\n}\nexports.values = values;\n"},"sourceMaps":{"js":{"version":3,"file":"properties.js","sourceRoot":"","sources":["../../../../src/compile/axis/properties.ts"],"names":[],"mappings":"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","sourcesContent":["import {truncate} from 'vega-util';\nimport {Axis} from '../../axis';\nimport {binToString} from '../../bin';\nimport {PositionScaleChannel, X, Y} from '../../channel';\nimport {Config} from '../../config';\nimport {FieldDef, title as fieldDefTitle, valueArray} from '../../fielddef';\nimport * as log from '../../log';\nimport {hasDiscreteDomain, isSelectionDomain, ScaleType} from '../../scale';\nimport {QUANTITATIVE} from '../../type';\nimport {contains} from '../../util';\nimport {VgSignalRef} from '../../vega.schema';\nimport {UnitModel} from '../unit';\n\n\n// TODO: we need to refactor this method after we take care of config refactoring\n/**\n * Default rules for whether to show a grid should be shown for a channel.\n * If `grid` is unspecified, the default value is `true` for ordinal scales that are not binned\n */\nexport function grid(scaleType: ScaleType, fieldDef: FieldDef<string>) {\n  return !hasDiscreteDomain(scaleType) && !fieldDef.bin;\n}\n\nexport function gridScale(model: UnitModel, channel: PositionScaleChannel) {\n  const gridChannel: PositionScaleChannel = channel === 'x' ? 'y' : 'x';\n  if (model.getScaleComponent(gridChannel)) {\n    return model.scaleName(gridChannel);\n  }\n  return undefined;\n}\n\nexport function labelFlush(fieldDef: FieldDef<string>, channel: PositionScaleChannel, specifiedAxis: Axis) {\n  if (specifiedAxis.labelFlush !== undefined) {\n    return specifiedAxis.labelFlush;\n  }\n  if (channel === 'x' && contains(['quantitative', 'temporal'], fieldDef.type)) {\n    return true;\n  }\n  return undefined;\n}\n\nexport function labelOverlap(fieldDef: FieldDef<string>, specifiedAxis: Axis, channel: PositionScaleChannel, scaleType: ScaleType) {\n  if (specifiedAxis.labelOverlap !== undefined) {\n    return specifiedAxis.labelOverlap;\n  }\n\n  // do not prevent overlap for nominal data because there is no way to infer what the missing labels are\n  if (fieldDef.type !== 'nominal') {\n    if (scaleType === 'log') {\n      return 'greedy';\n    }\n    return true;\n  }\n\n  return undefined;\n}\n\nexport function orient(channel: PositionScaleChannel) {\n  switch (channel) {\n    case X:\n      return 'bottom';\n    case Y:\n      return 'left';\n  }\n  /* istanbul ignore next: This should never happen. */\n  throw new Error(log.message.INVALID_CHANNEL_FOR_AXIS);\n}\n\nexport function tickCount(channel: PositionScaleChannel, fieldDef: FieldDef<string>, scaleType: ScaleType, size: VgSignalRef) {\n  if (!hasDiscreteDomain(scaleType) && scaleType !== 'log' && !contains(['month', 'hours', 'day', 'quarter'], fieldDef.timeUnit)) {\n\n    if (fieldDef.bin) {\n      // for binned data, we don't want more ticks than maxbins\n      return {signal: `ceil(${size.signal}/20)`};\n    }\n    return {signal: `ceil(${size.signal}/40)`};\n  }\n\n  return undefined;\n}\n\nexport function title(maxLength: number, fieldDef: FieldDef<string>, config: Config) {\n  // if not defined, automatically determine axis title from field def\n  const fieldTitle = fieldDefTitle(fieldDef, config);\n  return maxLength ? truncate(fieldTitle, maxLength) : fieldTitle;\n}\n\nexport function values(specifiedAxis: Axis, model: UnitModel, fieldDef: FieldDef<string>, channel: PositionScaleChannel) {\n  const vals = specifiedAxis.values;\n\n  if (vals) {\n    return valueArray(fieldDef, vals);\n  }\n\n  if (fieldDef.bin && fieldDef.type === QUANTITATIVE) {\n    const domain = model.scaleDomain(channel);\n    if (domain && domain !== 'unaggregated' && !isSelectionDomain(domain)) { // explicit value\n      return undefined;\n    }\n\n    const signal = model.getName(`${binToString(fieldDef.bin)}_${fieldDef.field}_bins`);\n    return {signal: `sequence(${signal}.start, ${signal}.stop + ${signal}.step, ${signal}.step)`};\n  }\n\n  return undefined;\n}\n"]}},"error":null,"hash":"a70531f4df68637bb9b352da39009b70","cacheData":{"env":{}}}