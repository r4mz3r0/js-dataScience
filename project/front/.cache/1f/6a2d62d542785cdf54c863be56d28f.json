{"id":"node_modules/vega-lite/build/src/compile/data/optimizers.js","dependencies":[{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/optimizers.js.map","includedInParent":true,"mtime":499162500000},{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/package.json","includedInParent":true,"mtime":1593715260815},{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/package.json","includedInParent":true,"mtime":499162500000},{"name":"tslib","loc":{"line":3,"column":22},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/optimizers.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/tslib/tslib.es6.js"},{"name":"../../util","loc":{"line":4,"column":21},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/optimizers.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/util.js"},{"name":"./dataflow","loc":{"line":5,"column":25},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/optimizers.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/dataflow.js"},{"name":"./facet","loc":{"line":6,"column":22},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/optimizers.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/facet.js"},{"name":"./formatparse","loc":{"line":7,"column":28},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/optimizers.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/formatparse.js"},{"name":"./source","loc":{"line":8,"column":23},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/optimizers.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/source.js"},{"name":"./timeunit","loc":{"line":9,"column":25},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/optimizers.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/timeunit.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar util_1 = require(\"../../util\");\nvar dataflow_1 = require(\"./dataflow\");\nvar facet_1 = require(\"./facet\");\nvar formatparse_1 = require(\"./formatparse\");\nvar source_1 = require(\"./source\");\nvar timeunit_1 = require(\"./timeunit\");\n/**\n * Start optimization path at the leaves. Useful for merging up or removing things.\n *\n * If the callback returns true, the recursion continues.\n */\nfunction iterateFromLeaves(f) {\n    function optimizeNextFromLeaves(node) {\n        if (node instanceof source_1.SourceNode) {\n            return;\n        }\n        var next = node.parent;\n        if (f(node)) {\n            optimizeNextFromLeaves(next);\n        }\n    }\n    return optimizeNextFromLeaves;\n}\nexports.iterateFromLeaves = iterateFromLeaves;\n/**\n * Move parse nodes up to forks.\n */\nfunction moveParseUp(node) {\n    var parent = node.parent;\n    // move parse up by merging or swapping\n    if (node instanceof formatparse_1.ParseNode) {\n        if (parent instanceof source_1.SourceNode) {\n            return false;\n        }\n        if (parent.numChildren() > 1) {\n            // don't move parse further up but continue with parent.\n            return true;\n        }\n        if (parent instanceof formatparse_1.ParseNode) {\n            parent.merge(node);\n        }\n        else {\n            // don't swap with nodes that produce something that the parse node depends on (e.g. lookup)\n            if (util_1.hasIntersection(parent.producedFields(), node.dependentFields())) {\n                return true;\n            }\n            node.swapWithParent();\n        }\n    }\n    return true;\n}\nexports.moveParseUp = moveParseUp;\n/**\n * Repeatedly remove leaf nodes that are not output or facet nodes.\n * The reason is that we don't need subtrees that don't have any output nodes.\n * Facet nodes are needed for the row or column domains.\n */\nfunction removeUnusedSubtrees(node) {\n    if (node instanceof dataflow_1.OutputNode || node.numChildren() > 0 || node instanceof facet_1.FacetNode) {\n        // no need to continue with parent because it is output node or will have children (there was a fork)\n        return false;\n    }\n    else {\n        node.remove();\n    }\n    return true;\n}\nexports.removeUnusedSubtrees = removeUnusedSubtrees;\n/**\n * Removes duplicate time unit nodes (as determined by the name of the\n * output field) that may be generated due to selections projected over\n * time units.\n */\nfunction removeDuplicateTimeUnits(leaf) {\n    var fields = {};\n    return iterateFromLeaves(function (node) {\n        if (node instanceof timeunit_1.TimeUnitNode) {\n            var pfields = node.producedFields();\n            var dupe = util_1.keys(pfields).every(function (k) { return !!fields[k]; });\n            if (dupe) {\n                node.remove();\n            }\n            else {\n                fields = tslib_1.__assign({}, fields, pfields);\n            }\n        }\n        return true;\n    })(leaf);\n}\nexports.removeDuplicateTimeUnits = removeDuplicateTimeUnits;\n"},"sourceMaps":{"js":{"version":3,"file":"optimizers.js","sourceRoot":"","sources":["../../../../src/compile/data/optimizers.ts"],"names":[],"mappings":";;;AAAA,mCAAiD;AACjD,uCAAoD;AACpD,iCAAkC;AAClC,6CAAwC;AACxC,mCAAoC;AACpC,uCAAwC;AAGxC;;;;GAIG;AACH,2BAAkC,CAAkC;IAClE,gCAAgC,IAAkB;QAChD,IAAI,IAAI,YAAY,mBAAU,EAAE;YAC9B,OAAO;SACR;QAED,IAAM,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC;QACzB,IAAI,CAAC,CAAC,IAAI,CAAC,EAAE;YACX,sBAAsB,CAAC,IAAI,CAAC,CAAC;SAC9B;IACH,CAAC;IAED,OAAO,sBAAsB,CAAC;AAChC,CAAC;AAbD,8CAaC;AAED;;GAEG;AACH,qBAA4B,IAAkB;IAC5C,IAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;IAE3B,uCAAuC;IACvC,IAAI,IAAI,YAAY,uBAAS,EAAE;QAC7B,IAAI,MAAM,YAAY,mBAAU,EAAE;YAChC,OAAO,KAAK,CAAC;SACd;QAED,IAAI,MAAM,CAAC,WAAW,EAAE,GAAG,CAAC,EAAE;YAC5B,wDAAwD;YACxD,OAAO,IAAI,CAAC;SACb;QAED,IAAI,MAAM,YAAY,uBAAS,EAAE;YAC/B,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;SACpB;aAAM;YACL,4FAA4F;YAC5F,IAAI,sBAAe,CAAC,MAAM,CAAC,cAAc,EAAE,EAAE,IAAI,CAAC,eAAe,EAAE,CAAC,EAAE;gBACpE,OAAO,IAAI,CAAC;aACb;YAED,IAAI,CAAC,cAAc,EAAE,CAAC;SACvB;KACF;IAED,OAAO,IAAI,CAAC;AACd,CAAC;AA3BD,kCA2BC;AAED;;;;GAIG;AACH,8BAAqC,IAAkB;IACrD,IAAI,IAAI,YAAY,qBAAU,IAAI,IAAI,CAAC,WAAW,EAAE,GAAG,CAAC,IAAI,IAAI,YAAY,iBAAS,EAAE;QACrF,qGAAqG;QACrG,OAAO,KAAK,CAAC;KACd;SAAM;QACL,IAAI,CAAC,MAAM,EAAE,CAAC;KACf;IACD,OAAO,IAAI,CAAC;AACd,CAAC;AARD,oDAQC;AAED;;;;GAIG;AACH,kCAAyC,IAAkB;IACzD,IAAI,MAAM,GAAG,EAAE,CAAC;IAChB,OAAO,iBAAiB,CAAC,UAAC,IAAkB;QAC1C,IAAI,IAAI,YAAY,uBAAY,EAAE;YAChC,IAAM,OAAO,GAAG,IAAI,CAAC,cAAc,EAAE,CAAC;YACtC,IAAM,IAAI,GAAG,WAAI,CAAC,OAAO,CAAC,CAAC,KAAK,CAAC,UAAC,CAAC,IAAK,OAAA,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,EAAX,CAAW,CAAC,CAAC;YAErD,IAAI,IAAI,EAAE;gBACR,IAAI,CAAC,MAAM,EAAE,CAAC;aACf;iBAAM;gBACL,MAAM,wBAAO,MAAM,EAAK,OAAO,CAAC,CAAC;aAClC;SACF;QAED,OAAO,IAAI,CAAC;IACd,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;AACX,CAAC;AAhBD,4DAgBC","sourcesContent":["import {hasIntersection, keys} from '../../util';\nimport {DataFlowNode, OutputNode} from './dataflow';\nimport {FacetNode} from './facet';\nimport {ParseNode} from './formatparse';\nimport {SourceNode} from './source';\nimport {TimeUnitNode} from './timeunit';\n\n\n/**\n * Start optimization path at the leaves. Useful for merging up or removing things.\n *\n * If the callback returns true, the recursion continues.\n */\nexport function iterateFromLeaves(f: (node: DataFlowNode) => boolean) {\n  function optimizeNextFromLeaves(node: DataFlowNode) {\n    if (node instanceof SourceNode) {\n      return;\n    }\n\n    const next = node.parent;\n    if (f(node)) {\n      optimizeNextFromLeaves(next);\n    }\n  }\n\n  return optimizeNextFromLeaves;\n}\n\n/**\n * Move parse nodes up to forks.\n */\nexport function moveParseUp(node: DataFlowNode) {\n  const parent = node.parent;\n\n  // move parse up by merging or swapping\n  if (node instanceof ParseNode) {\n    if (parent instanceof SourceNode) {\n      return false;\n    }\n\n    if (parent.numChildren() > 1) {\n      // don't move parse further up but continue with parent.\n      return true;\n    }\n\n    if (parent instanceof ParseNode) {\n      parent.merge(node);\n    } else {\n      // don't swap with nodes that produce something that the parse node depends on (e.g. lookup)\n      if (hasIntersection(parent.producedFields(), node.dependentFields())) {\n        return true;\n      }\n\n      node.swapWithParent();\n    }\n  }\n\n  return true;\n}\n\n/**\n * Repeatedly remove leaf nodes that are not output or facet nodes.\n * The reason is that we don't need subtrees that don't have any output nodes.\n * Facet nodes are needed for the row or column domains.\n */\nexport function removeUnusedSubtrees(node: DataFlowNode) {\n  if (node instanceof OutputNode || node.numChildren() > 0 || node instanceof FacetNode) {\n    // no need to continue with parent because it is output node or will have children (there was a fork)\n    return false;\n  } else {\n    node.remove();\n  }\n  return true;\n}\n\n/**\n * Removes duplicate time unit nodes (as determined by the name of the\n * output field) that may be generated due to selections projected over\n * time units.\n */\nexport function removeDuplicateTimeUnits(leaf: DataFlowNode) {\n  let fields = {};\n  return iterateFromLeaves((node: DataFlowNode) => {\n    if (node instanceof TimeUnitNode) {\n      const pfields = node.producedFields();\n      const dupe = keys(pfields).every((k) => !!fields[k]);\n\n      if (dupe) {\n        node.remove();\n      } else {\n        fields = {...fields, ...pfields};\n      }\n    }\n\n    return true;\n  })(leaf);\n}\n"]}},"error":null,"hash":"e5a3436e707c4354a9995863d24410b2","cacheData":{"env":{}}}