{"id":"node_modules/vega-lite/build/src/compile/data/geopoint.js","dependencies":[{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/geopoint.js.map","includedInParent":true,"mtime":499162500000},{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/package.json","includedInParent":true,"mtime":1593715260815},{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/package.json","includedInParent":true,"mtime":499162500000},{"name":"tslib","loc":{"line":3,"column":22},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/geopoint.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/tslib/tslib.es6.js"},{"name":"../../channel","loc":{"line":4,"column":24},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/geopoint.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/channel.js"},{"name":"../../util","loc":{"line":5,"column":21},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/geopoint.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/util.js"},{"name":"./dataflow","loc":{"line":6,"column":25},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/geopoint.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/data/dataflow.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar channel_1 = require(\"../../channel\");\nvar util_1 = require(\"../../util\");\nvar dataflow_1 = require(\"./dataflow\");\nvar GeoPointNode = /** @class */ (function (_super) {\n    tslib_1.__extends(GeoPointNode, _super);\n    function GeoPointNode(parent, projection, fields, as) {\n        var _this = _super.call(this, parent) || this;\n        _this.projection = projection;\n        _this.fields = fields;\n        _this.as = as;\n        return _this;\n    }\n    GeoPointNode.prototype.clone = function () {\n        return new GeoPointNode(null, this.projection, util_1.duplicate(this.fields), util_1.duplicate(this.as));\n    };\n    GeoPointNode.parseAll = function (parent, model) {\n        if (!model.projectionName()) {\n            return parent;\n        }\n        [[channel_1.LONGITUDE, channel_1.LATITUDE], [channel_1.LONGITUDE2, channel_1.LATITUDE2]].forEach(function (coordinates) {\n            var pair = coordinates.map(function (channel) { return model.channelHasField(channel) ? model.fieldDef(channel).field : undefined; });\n            var suffix = coordinates[0] === channel_1.LONGITUDE2 ? '2' : '';\n            if (pair[0] || pair[1]) {\n                parent = new GeoPointNode(parent, model.projectionName(), pair, [model.getName('x' + suffix), model.getName('y' + suffix)]);\n            }\n        });\n        return parent;\n    };\n    GeoPointNode.prototype.assemble = function () {\n        return {\n            type: 'geopoint',\n            projection: this.projection,\n            fields: this.fields,\n            as: this.as\n        };\n    };\n    return GeoPointNode;\n}(dataflow_1.DataFlowNode));\nexports.GeoPointNode = GeoPointNode;\n"},"sourceMaps":{"js":{"version":3,"file":"geopoint.js","sourceRoot":"","sources":["../../../../src/compile/data/geopoint.ts"],"names":[],"mappings":";;;AAAA,yCAA6F;AAC7F,mCAAqC;AAGrC,uCAAwC;AAGxC;IAAkC,wCAAY;IAK5C,sBAAY,MAAoB,EAAU,UAAkB,EAAU,MAAgB,EAAU,EAAY;QAA5G,YACE,kBAAM,MAAM,CAAC,SACd;QAFyC,gBAAU,GAAV,UAAU,CAAQ;QAAU,YAAM,GAAN,MAAM,CAAU;QAAU,QAAE,GAAF,EAAE,CAAU;;IAE5G,CAAC;IANM,4BAAK,GAAZ;QACE,OAAO,IAAI,YAAY,CAAC,IAAI,EAAE,IAAI,CAAC,UAAU,EAAE,gBAAS,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,gBAAS,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC;IAC7F,CAAC;IAMa,qBAAQ,GAAtB,UAAuB,MAAoB,EAAE,KAAgB;QAC3D,IAAI,CAAC,KAAK,CAAC,cAAc,EAAE,EAAE;YAC3B,OAAO,MAAM,CAAC;SACf;QAED,CAAC,CAAC,mBAAS,EAAE,kBAAQ,CAAC,EAAE,CAAC,oBAAU,EAAE,mBAAS,CAAC,CAAC,CAAC,OAAO,CAAC,UAAC,WAAiC;YACzF,IAAM,IAAI,GAAG,WAAW,CAAC,GAAG,CAC1B,UAAA,OAAO,IAAI,OAAA,KAAK,CAAC,eAAe,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,SAAS,EAA1E,CAA0E,CACtF,CAAC;YAEF,IAAM,MAAM,GAAG,WAAW,CAAC,CAAC,CAAC,KAAK,oBAAU,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC;YAExD,IAAI,IAAI,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC,EAAE;gBACtB,MAAM,GAAG,IAAI,YAAY,CACvB,MAAM,EACN,KAAK,CAAC,cAAc,EAAE,EACtB,IAAI,EACJ,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,GAAG,MAAM,CAAC,EAAE,KAAK,CAAC,OAAO,CAAC,GAAG,GAAG,MAAM,CAAC,CAAC,CAC3D,CAAC;aACH;QACH,CAAC,CAAC,CAAC;QAEH,OAAO,MAAM,CAAC;IAChB,CAAC;IAEM,+BAAQ,GAAf;QACE,OAAO;YACL,IAAI,EAAE,UAAU;YAChB,UAAU,EAAE,IAAI,CAAC,UAAU;YAC3B,MAAM,EAAE,IAAI,CAAC,MAAM;YACnB,EAAE,EAAE,IAAI,CAAC,EAAE;SACZ,CAAC;IACJ,CAAC;IACH,mBAAC;AAAD,CAAC,AA1CD,CAAkC,uBAAY,GA0C7C;AA1CY,oCAAY","sourcesContent":["import {GeoPositionChannel, LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2} from '../../channel';\nimport {duplicate} from '../../util';\nimport {VgGeoPointTransform} from '../../vega.schema';\nimport {UnitModel} from '../unit';\nimport {DataFlowNode} from './dataflow';\n\n\nexport class GeoPointNode extends DataFlowNode {\n  public clone() {\n    return new GeoPointNode(null, this.projection, duplicate(this.fields), duplicate(this.as));\n  }\n\n  constructor(parent: DataFlowNode, private projection: string, private fields: string[], private as: string[]) {\n    super(parent);\n  }\n\n  public static parseAll(parent: DataFlowNode, model: UnitModel): DataFlowNode {\n    if (!model.projectionName()) {\n      return parent;\n    }\n\n    [[LONGITUDE, LATITUDE], [LONGITUDE2, LATITUDE2]].forEach((coordinates: GeoPositionChannel[]) => {\n      const pair = coordinates.map(\n        channel => model.channelHasField(channel) ? model.fieldDef(channel).field : undefined\n      );\n\n      const suffix = coordinates[0] === LONGITUDE2 ? '2' : '';\n\n      if (pair[0] || pair[1]) {\n        parent = new GeoPointNode(\n          parent,\n          model.projectionName(),\n          pair,\n          [model.getName('x' + suffix), model.getName('y' + suffix)]\n        );\n      }\n    });\n\n    return parent;\n  }\n\n  public assemble(): VgGeoPointTransform {\n    return {\n      type: 'geopoint',\n      projection: this.projection,\n      fields: this.fields,\n      as: this.as\n    };\n  }\n}\n"]}},"error":null,"hash":"b9651a483e49ffc81881cc47d4967ef6","cacheData":{"env":{}}}