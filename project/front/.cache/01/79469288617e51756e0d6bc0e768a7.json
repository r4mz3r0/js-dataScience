{"id":"node_modules/vega-lite/build/src/compile/mark/rect.js","dependencies":[{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/rect.js.map","includedInParent":true,"mtime":499162500000},{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/package.json","includedInParent":true,"mtime":1593715260815},{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/package.json","includedInParent":true,"mtime":499162500000},{"name":"tslib","loc":{"line":3,"column":22},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/rect.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/tslib/tslib.es6.js"},{"name":"../../channel","loc":{"line":4,"column":24},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/rect.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/channel.js"},{"name":"../../fielddef","loc":{"line":5,"column":25},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/rect.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/fielddef.js"},{"name":"../../log","loc":{"line":6,"column":39},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/rect.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/log.js"},{"name":"../../mark","loc":{"line":7,"column":21},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/rect.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/mark.js"},{"name":"../../scale","loc":{"line":8,"column":22},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/rect.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/scale.js"},{"name":"./mixins","loc":{"line":9,"column":42},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/rect.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/compile/mark/mixins.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar channel_1 = require(\"../../channel\");\nvar fielddef_1 = require(\"../../fielddef\");\nvar log = tslib_1.__importStar(require(\"../../log\"));\nvar mark_1 = require(\"../../mark\");\nvar scale_1 = require(\"../../scale\");\nvar mixins = tslib_1.__importStar(require(\"./mixins\"));\nexports.rect = {\n    vgMark: 'rect',\n    encodeEntry: function (model) {\n        return tslib_1.__assign({}, mixins.baseEncodeEntry(model, { size: 'ignore', orient: 'ignore' }), x(model), y(model));\n    }\n};\nfunction x(model) {\n    var xDef = model.encoding.x;\n    var x2Def = model.encoding.x2;\n    var xScale = model.getScaleComponent(channel_1.X);\n    var xScaleType = xScale ? xScale.get('type') : undefined;\n    if (fielddef_1.isFieldDef(xDef) && xDef.bin && !x2Def) {\n        return mixins.binnedPosition(xDef, 'x', model.scaleName('x'), 0, xScale.get('reverse'));\n    }\n    else if (fielddef_1.isFieldDef(xDef) && xScale && scale_1.hasDiscreteDomain(xScaleType)) {\n        /* istanbul ignore else */\n        if (xScaleType === scale_1.ScaleType.BAND) {\n            return mixins.bandPosition(xDef, 'x', model);\n        }\n        else {\n            // We don't support rect mark with point/ordinal scale\n            throw new Error(log.message.scaleTypeNotWorkWithMark(mark_1.RECT, xScaleType));\n        }\n    }\n    else { // continuous scale or no scale\n        return tslib_1.__assign({}, mixins.pointPosition('x', model, 'zeroOrMax'), mixins.pointPosition2(model, 'zeroOrMin', 'x2'));\n    }\n}\nexports.x = x;\nfunction y(model) {\n    var yDef = model.encoding.y;\n    var y2Def = model.encoding.y2;\n    var yScale = model.getScaleComponent(channel_1.Y);\n    var yScaleType = yScale ? yScale.get('type') : undefined;\n    if (fielddef_1.isFieldDef(yDef) && yDef.bin && !y2Def) {\n        return mixins.binnedPosition(yDef, 'y', model.scaleName('y'), 0, yScale.get('reverse'));\n    }\n    else if (fielddef_1.isFieldDef(yDef) && yScale && scale_1.hasDiscreteDomain(yScaleType)) {\n        /* istanbul ignore else */\n        if (yScaleType === scale_1.ScaleType.BAND) {\n            return mixins.bandPosition(yDef, 'y', model);\n        }\n        else {\n            // We don't support rect mark with point/ordinal scale\n            throw new Error(log.message.scaleTypeNotWorkWithMark(mark_1.RECT, yScaleType));\n        }\n    }\n    else { // continuous scale or no scale\n        return tslib_1.__assign({}, mixins.pointPosition('y', model, 'zeroOrMax'), mixins.pointPosition2(model, 'zeroOrMin', 'y2'));\n    }\n}\nexports.y = y;\n"},"sourceMaps":{"js":{"version":3,"file":"rect.js","sourceRoot":"","sources":["../../../../src/compile/mark/rect.ts"],"names":[],"mappings":"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","sourcesContent":["import {X, Y} from '../../channel';\nimport {isFieldDef} from '../../fielddef';\nimport * as log from '../../log';\nimport {RECT} from '../../mark';\nimport {hasDiscreteDomain, ScaleType} from '../../scale';\nimport {VgEncodeEntry} from '../../vega.schema';\nimport {UnitModel} from '../unit';\nimport {MarkCompiler} from './base';\nimport * as mixins from './mixins';\n\nexport const rect: MarkCompiler = {\n  vgMark: 'rect',\n  encodeEntry: (model: UnitModel) => {\n    return {\n      ...mixins.baseEncodeEntry(model, {size: 'ignore', orient: 'ignore'}),\n      ...x(model),\n      ...y(model),\n    };\n  }\n};\n\nexport function x(model: UnitModel): VgEncodeEntry {\n  const xDef = model.encoding.x;\n  const x2Def = model.encoding.x2;\n  const xScale = model.getScaleComponent(X);\n  const xScaleType = xScale ? xScale.get('type') : undefined;\n\n  if (isFieldDef(xDef) && xDef.bin && !x2Def) {\n    return mixins.binnedPosition(xDef, 'x', model.scaleName('x'), 0, xScale.get('reverse'));\n  } else if (isFieldDef(xDef) && xScale && hasDiscreteDomain(xScaleType)) {\n    /* istanbul ignore else */\n    if (xScaleType === ScaleType.BAND) {\n      return mixins.bandPosition(xDef, 'x', model);\n    } else {\n      // We don't support rect mark with point/ordinal scale\n      throw new Error(log.message.scaleTypeNotWorkWithMark(RECT, xScaleType));\n    }\n  } else { // continuous scale or no scale\n    return {\n      ...mixins.pointPosition('x', model, 'zeroOrMax'),\n      ...mixins.pointPosition2(model, 'zeroOrMin', 'x2')\n    };\n  }\n}\n\nexport function y(model: UnitModel): VgEncodeEntry {\n  const yDef = model.encoding.y;\n  const y2Def = model.encoding.y2;\n  const yScale = model.getScaleComponent(Y);\n  const yScaleType = yScale ? yScale.get('type') : undefined;\n\n  if (isFieldDef(yDef) && yDef.bin && !y2Def) {\n    return mixins.binnedPosition(yDef, 'y', model.scaleName('y'), 0, yScale.get('reverse'));\n  } else if (isFieldDef(yDef) && yScale && hasDiscreteDomain(yScaleType)) {\n    /* istanbul ignore else */\n    if (yScaleType === ScaleType.BAND) {\n      return mixins.bandPosition(yDef, 'y', model);\n    } else {\n      // We don't support rect mark with point/ordinal scale\n      throw new Error(log.message.scaleTypeNotWorkWithMark(RECT, yScaleType));\n    }\n  } else { // continuous scale or no scale\n    return {\n      ...mixins.pointPosition('y', model, 'zeroOrMax'),\n      ...mixins.pointPosition2(model, 'zeroOrMin', 'y2')\n    };\n  }\n}\n"]}},"error":null,"hash":"278cb8e925d1238a3f8652615075d02b","cacheData":{"env":{}}}