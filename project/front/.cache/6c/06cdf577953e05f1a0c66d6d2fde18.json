{"id":"node_modules/vega-lite/build/src/channel.js","dependencies":[{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/channel.js.map","includedInParent":true,"mtime":499162500000},{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/package.json","includedInParent":true,"mtime":1593715260815},{"name":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/package.json","includedInParent":true,"mtime":499162500000},{"name":"tslib","loc":{"line":7,"column":22},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/channel.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/tslib/tslib.es6.js"},{"name":"./util","loc":{"line":8,"column":21},"parent":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/channel.js","resolved":"/home/ramsiro/Desktop/JavaScriptDataScience/js-dataScience/project/front/node_modules/vega-lite/build/src/util.js"}],"generated":{"js":"\"use strict\";\n/*\n * Constants and utilities for encoding channels (Visual variables)\n * such as 'x', 'y', 'color'.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar util_1 = require(\"./util\");\nvar Channel;\n(function (Channel) {\n    // Facet\n    Channel.ROW = 'row';\n    Channel.COLUMN = 'column';\n    // Position\n    Channel.X = 'x';\n    Channel.Y = 'y';\n    Channel.X2 = 'x2';\n    Channel.Y2 = 'y2';\n    // Geo Position\n    Channel.LATITUDE = 'latitude';\n    Channel.LONGITUDE = 'longitude';\n    Channel.LATITUDE2 = 'latitude2';\n    Channel.LONGITUDE2 = 'longitude2';\n    // Mark property with scale\n    Channel.COLOR = 'color';\n    Channel.FILL = 'fill';\n    Channel.STROKE = 'stroke';\n    Channel.SHAPE = 'shape';\n    Channel.SIZE = 'size';\n    Channel.OPACITY = 'opacity';\n    // Non-scale channel\n    Channel.TEXT = 'text';\n    Channel.ORDER = 'order';\n    Channel.DETAIL = 'detail';\n    Channel.KEY = 'key';\n    Channel.TOOLTIP = 'tooltip';\n    Channel.HREF = 'href';\n})(Channel = exports.Channel || (exports.Channel = {}));\nexports.X = Channel.X;\nexports.Y = Channel.Y;\nexports.X2 = Channel.X2;\nexports.Y2 = Channel.Y2;\nexports.LATITUDE = Channel.LATITUDE;\nexports.LATITUDE2 = Channel.LATITUDE2;\nexports.LONGITUDE = Channel.LONGITUDE;\nexports.LONGITUDE2 = Channel.LONGITUDE2;\nexports.ROW = Channel.ROW;\nexports.COLUMN = Channel.COLUMN;\nexports.SHAPE = Channel.SHAPE;\nexports.SIZE = Channel.SIZE;\nexports.COLOR = Channel.COLOR;\nexports.FILL = Channel.FILL;\nexports.STROKE = Channel.STROKE;\nexports.TEXT = Channel.TEXT;\nexports.DETAIL = Channel.DETAIL;\nexports.KEY = Channel.KEY;\nexports.ORDER = Channel.ORDER;\nexports.OPACITY = Channel.OPACITY;\nexports.TOOLTIP = Channel.TOOLTIP;\nexports.HREF = Channel.HREF;\nexports.GEOPOSITION_CHANNEL_INDEX = {\n    longitude: 1,\n    longitude2: 1,\n    latitude: 1,\n    latitude2: 1,\n};\nexports.GEOPOSITION_CHANNELS = util_1.flagKeys(exports.GEOPOSITION_CHANNEL_INDEX);\nvar UNIT_CHANNEL_INDEX = tslib_1.__assign({ \n    // position\n    x: 1, y: 1, x2: 1, y2: 1 }, exports.GEOPOSITION_CHANNEL_INDEX, { \n    // color\n    color: 1, fill: 1, stroke: 1, \n    // other non-position with scale\n    opacity: 1, size: 1, shape: 1, \n    // channels without scales\n    order: 1, text: 1, detail: 1, key: 1, tooltip: 1, href: 1 });\nfunction isColorChannel(channel) {\n    return channel === 'color' || channel === 'fill' || channel === 'stroke';\n}\nexports.isColorChannel = isColorChannel;\nvar FACET_CHANNEL_INDEX = {\n    row: 1,\n    column: 1\n};\nvar CHANNEL_INDEX = tslib_1.__assign({}, UNIT_CHANNEL_INDEX, FACET_CHANNEL_INDEX);\nexports.CHANNELS = util_1.flagKeys(CHANNEL_INDEX);\nvar _o = CHANNEL_INDEX.order, _d = CHANNEL_INDEX.detail, SINGLE_DEF_CHANNEL_INDEX = tslib_1.__rest(CHANNEL_INDEX, [\"order\", \"detail\"]);\n/**\n * Channels that cannot have an array of channelDef.\n * model.fieldDef, getFieldDef only work for these channels.\n *\n * (The only two channels that can have an array of channelDefs are \"detail\" and \"order\".\n * Since there can be multiple fieldDefs for detail and order, getFieldDef/model.fieldDef\n * are not applicable for them.  Similarly, selection projection won't work with \"detail\" and \"order\".)\n */\nexports.SINGLE_DEF_CHANNELS = util_1.flagKeys(SINGLE_DEF_CHANNEL_INDEX);\nfunction isChannel(str) {\n    return !!CHANNEL_INDEX[str];\n}\nexports.isChannel = isChannel;\n// CHANNELS without COLUMN, ROW\nexports.UNIT_CHANNELS = util_1.flagKeys(UNIT_CHANNEL_INDEX);\n// NONPOSITION_CHANNELS = UNIT_CHANNELS without X, Y, X2, Y2;\nvar _x = UNIT_CHANNEL_INDEX.x, _y = UNIT_CHANNEL_INDEX.y, \n// x2 and y2 share the same scale as x and y\n_x2 = UNIT_CHANNEL_INDEX.x2, _y2 = UNIT_CHANNEL_INDEX.y2, _latitude = UNIT_CHANNEL_INDEX.latitude, _longitude = UNIT_CHANNEL_INDEX.longitude, _latitude2 = UNIT_CHANNEL_INDEX.latitude2, _longitude2 = UNIT_CHANNEL_INDEX.longitude2, \n// The rest of unit channels then have scale\nNONPOSITION_CHANNEL_INDEX = tslib_1.__rest(UNIT_CHANNEL_INDEX, [\"x\", \"y\", \"x2\", \"y2\", \"latitude\", \"longitude\", \"latitude2\", \"longitude2\"]);\nexports.NONPOSITION_CHANNELS = util_1.flagKeys(NONPOSITION_CHANNEL_INDEX);\n// POSITION_SCALE_CHANNELS = X and Y;\nvar POSITION_SCALE_CHANNEL_INDEX = { x: 1, y: 1 };\nexports.POSITION_SCALE_CHANNELS = util_1.flagKeys(POSITION_SCALE_CHANNEL_INDEX);\n// NON_POSITION_SCALE_CHANNEL = SCALE_CHANNELS without X, Y\nvar \n// x2 and y2 share the same scale as x and y\n// text and tooltip have format instead of scale,\n// href has neither format, nor scale\n_t = NONPOSITION_CHANNEL_INDEX.text, _tt = NONPOSITION_CHANNEL_INDEX.tooltip, _hr = NONPOSITION_CHANNEL_INDEX.href, \n// detail and order have no scale\n_dd = NONPOSITION_CHANNEL_INDEX.detail, _k = NONPOSITION_CHANNEL_INDEX.key, _oo = NONPOSITION_CHANNEL_INDEX.order, NONPOSITION_SCALE_CHANNEL_INDEX = tslib_1.__rest(NONPOSITION_CHANNEL_INDEX, [\"text\", \"tooltip\", \"href\", \"detail\", \"key\", \"order\"]);\nexports.NONPOSITION_SCALE_CHANNELS = util_1.flagKeys(NONPOSITION_SCALE_CHANNEL_INDEX);\n// Declare SCALE_CHANNEL_INDEX\nvar SCALE_CHANNEL_INDEX = tslib_1.__assign({}, POSITION_SCALE_CHANNEL_INDEX, NONPOSITION_SCALE_CHANNEL_INDEX);\n/** List of channels with scales */\nexports.SCALE_CHANNELS = util_1.flagKeys(SCALE_CHANNEL_INDEX);\nfunction isScaleChannel(channel) {\n    return !!SCALE_CHANNEL_INDEX[channel];\n}\nexports.isScaleChannel = isScaleChannel;\n/**\n * Return whether a channel supports a particular mark type.\n * @param channel  channel name\n * @param mark the mark type\n * @return whether the mark supports the channel\n */\nfunction supportMark(channel, mark) {\n    return mark in getSupportedMark(channel);\n}\nexports.supportMark = supportMark;\n/**\n * Return a dictionary showing whether a channel supports mark type.\n * @param channel\n * @return A dictionary mapping mark types to boolean values.\n */\nfunction getSupportedMark(channel) {\n    switch (channel) {\n        case exports.COLOR:\n        case exports.FILL:\n        case exports.STROKE:\n        case exports.DETAIL:\n        case exports.KEY:\n        case exports.TOOLTIP:\n        case exports.HREF:\n        case exports.ORDER: // TODO: revise (order might not support rect, which is not stackable?)\n        case exports.OPACITY:\n        case exports.ROW:\n        case exports.COLUMN:\n            return {\n                point: true, tick: true, rule: true, circle: true, square: true,\n                bar: true, rect: true, line: true, trail: true, area: true, text: true, geoshape: true\n            };\n        case exports.X:\n        case exports.Y:\n        case exports.LATITUDE:\n        case exports.LONGITUDE:\n            return {\n                point: true, tick: true, rule: true, circle: true, square: true,\n                bar: true, rect: true, line: true, trail: true, area: true, text: true\n            };\n        case exports.X2:\n        case exports.Y2:\n        case exports.LATITUDE2:\n        case exports.LONGITUDE2:\n            return {\n                rule: true, bar: true, rect: true, area: true\n            };\n        case exports.SIZE:\n            return {\n                point: true, tick: true, rule: true, circle: true, square: true,\n                bar: true, text: true, line: true, trail: true\n            };\n        case exports.SHAPE:\n            return { point: true, geoshape: true };\n        case exports.TEXT:\n            return { text: true };\n    }\n}\nexports.getSupportedMark = getSupportedMark;\nfunction rangeType(channel) {\n    switch (channel) {\n        case exports.X:\n        case exports.Y:\n        case exports.SIZE:\n        case exports.OPACITY:\n        // X2 and Y2 use X and Y scales, so they similarly have continuous range.\n        case exports.X2:\n        case exports.Y2:\n            return 'continuous';\n        case exports.ROW:\n        case exports.COLUMN:\n        case exports.SHAPE:\n        // TEXT, TOOLTIP, and HREF have no scale but have discrete output\n        case exports.TEXT:\n        case exports.TOOLTIP:\n        case exports.HREF:\n            return 'discrete';\n        // Color can be either continuous or discrete, depending on scale type.\n        case exports.COLOR:\n        case exports.FILL:\n        case exports.STROKE:\n            return 'flexible';\n        // No scale, no range type.\n        case exports.LATITUDE:\n        case exports.LONGITUDE:\n        case exports.LATITUDE2:\n        case exports.LONGITUDE2:\n        case exports.DETAIL:\n        case exports.KEY:\n        case exports.ORDER:\n            return undefined;\n    }\n    /* istanbul ignore next: should never reach here. */\n    throw new Error('rangeType not implemented for ' + channel);\n}\nexports.rangeType = rangeType;\n"},"sourceMaps":{"js":{"version":3,"file":"channel.js","sourceRoot":"","sources":["../../src/channel.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Constants and utilities for encoding channels (Visual variables)\n * such as 'x', 'y', 'color'.\n */\n\nimport {RangeType} from './compile/scale/type';\nimport {Encoding} from './encoding';\nimport {FacetMapping} from './facet';\nimport {Mark} from './mark';\nimport {Flag, flagKeys} from './util';\n\nexport namespace Channel {\n  // Facet\n  export const ROW: 'row' = 'row';\n  export const COLUMN: 'column' = 'column';\n\n  // Position\n  export const X: 'x' = 'x';\n  export const Y: 'y' = 'y';\n  export const X2: 'x2' = 'x2';\n  export const Y2: 'y2' = 'y2';\n\n  // Geo Position\n  export const LATITUDE: 'latitude' = 'latitude';\n  export const LONGITUDE: 'longitude' = 'longitude';\n  export const LATITUDE2: 'latitude2' = 'latitude2';\n  export const LONGITUDE2: 'longitude2' = 'longitude2';\n\n  // Mark property with scale\n  export const COLOR: 'color' = 'color';\n\n  export const FILL: 'fill' = 'fill';\n\n  export const STROKE: 'stroke' = 'stroke';\n\n  export const SHAPE: 'shape' = 'shape';\n  export const SIZE: 'size' = 'size';\n  export const OPACITY: 'opacity' = 'opacity';\n\n  // Non-scale channel\n  export const TEXT: 'text' = 'text';\n  export const ORDER: 'order' = 'order';\n  export const DETAIL: 'detail' = 'detail';\n  export const KEY: 'key' = 'key';\n\n  export const TOOLTIP: 'tooltip' = 'tooltip';\n  export const HREF: 'href' = 'href';\n}\n\nexport type Channel = keyof Encoding<any> | keyof FacetMapping<any>;\n\nexport const X = Channel.X;\nexport const Y = Channel.Y;\nexport const X2 = Channel.X2;\nexport const Y2 = Channel.Y2;\n\nexport const LATITUDE = Channel.LATITUDE;\nexport const LATITUDE2 = Channel.LATITUDE2;\nexport const LONGITUDE = Channel.LONGITUDE;\nexport const LONGITUDE2 = Channel.LONGITUDE2;\n\nexport const ROW = Channel.ROW;\nexport const COLUMN = Channel.COLUMN;\nexport const SHAPE = Channel.SHAPE;\nexport const SIZE = Channel.SIZE;\nexport const COLOR = Channel.COLOR;\n\nexport const FILL = Channel.FILL;\nexport const STROKE = Channel.STROKE;\nexport const TEXT = Channel.TEXT;\nexport const DETAIL = Channel.DETAIL;\nexport const KEY = Channel.KEY;\nexport const ORDER = Channel.ORDER;\nexport const OPACITY = Channel.OPACITY;\nexport const TOOLTIP = Channel.TOOLTIP;\nexport const HREF = Channel.HREF;\n\nexport type GeoPositionChannel = 'longitude' | 'latitude' | 'longitude2' | 'latitude2';\n\nexport const GEOPOSITION_CHANNEL_INDEX: Flag<GeoPositionChannel> = {\n  longitude: 1,\n  longitude2: 1,\n  latitude: 1,\n  latitude2: 1,\n};\n\nexport const GEOPOSITION_CHANNELS = flagKeys(GEOPOSITION_CHANNEL_INDEX);\n\nconst UNIT_CHANNEL_INDEX: Flag<keyof Encoding<any>> = {\n  // position\n  x: 1,\n  y: 1,\n  x2: 1,\n  y2: 1,\n\n  ...GEOPOSITION_CHANNEL_INDEX,\n\n  // color\n  color: 1,\n  fill: 1,\n  stroke: 1,\n\n  // other non-position with scale\n  opacity: 1,\n  size: 1,\n  shape: 1,\n\n  // channels without scales\n  order: 1,\n  text: 1,\n  detail: 1,\n  key: 1,\n  tooltip: 1,\n  href: 1,\n};\n\nexport type ColorChannel = 'color' | 'fill' | 'stroke';\n\nexport function isColorChannel(channel: Channel): channel is ColorChannel {\n  return channel === 'color' || channel === 'fill' || channel === 'stroke';\n}\n\nconst FACET_CHANNEL_INDEX: Flag<keyof FacetMapping<any>> = {\n  row: 1,\n  column: 1\n};\n\nconst CHANNEL_INDEX = {\n  ...UNIT_CHANNEL_INDEX,\n  ...FACET_CHANNEL_INDEX\n};\n\nexport const CHANNELS = flagKeys(CHANNEL_INDEX);\n\nconst {order: _o, detail: _d, ...SINGLE_DEF_CHANNEL_INDEX} = CHANNEL_INDEX;\n/**\n * Channels that cannot have an array of channelDef.\n * model.fieldDef, getFieldDef only work for these channels.\n *\n * (The only two channels that can have an array of channelDefs are \"detail\" and \"order\".\n * Since there can be multiple fieldDefs for detail and order, getFieldDef/model.fieldDef\n * are not applicable for them.  Similarly, selection projection won't work with \"detail\" and \"order\".)\n */\n\nexport const SINGLE_DEF_CHANNELS: SingleDefChannel[] = flagKeys(SINGLE_DEF_CHANNEL_INDEX);\n\n// Using the following line leads to TypeError: Cannot read property 'elementTypes' of undefined\n// when running the schema generator\n// export type SingleDefChannel = typeof SINGLE_DEF_CHANNELS[0];\nexport type SingleDefChannel = 'x' | 'y' | 'x2' | 'y2' |\n  'longitude' | 'latitude' | 'longitude2' | 'latitude2' |\n  'row' | 'column' |\n  'color' | 'fill' | 'stroke' |\n  'size' | 'shape' | 'opacity' |\n  'text' | 'tooltip' | 'href' | 'key';\n\nexport function isChannel(str: string): str is Channel {\n  return !!CHANNEL_INDEX[str];\n}\n\n// CHANNELS without COLUMN, ROW\nexport const UNIT_CHANNELS = flagKeys(UNIT_CHANNEL_INDEX);\n\n\n// NONPOSITION_CHANNELS = UNIT_CHANNELS without X, Y, X2, Y2;\nconst {\n  x: _x, y: _y,\n  // x2 and y2 share the same scale as x and y\n  x2: _x2, y2: _y2,\n  latitude: _latitude, longitude: _longitude,\n  latitude2: _latitude2, longitude2: _longitude2,\n  // The rest of unit channels then have scale\n  ...NONPOSITION_CHANNEL_INDEX\n} = UNIT_CHANNEL_INDEX;\n\nexport const NONPOSITION_CHANNELS = flagKeys(NONPOSITION_CHANNEL_INDEX);\nexport type NonPositionChannel = typeof NONPOSITION_CHANNELS[0];\n\n// POSITION_SCALE_CHANNELS = X and Y;\nconst POSITION_SCALE_CHANNEL_INDEX: {x:1, y:1} = {x:1, y:1};\nexport const POSITION_SCALE_CHANNELS = flagKeys(POSITION_SCALE_CHANNEL_INDEX);\nexport type PositionScaleChannel = typeof POSITION_SCALE_CHANNELS[0];\n\n// NON_POSITION_SCALE_CHANNEL = SCALE_CHANNELS without X, Y\nconst {\n  // x2 and y2 share the same scale as x and y\n  // text and tooltip have format instead of scale,\n  // href has neither format, nor scale\n  text: _t, tooltip: _tt, href: _hr,\n  // detail and order have no scale\n  detail: _dd, key: _k, order: _oo,\n  ...NONPOSITION_SCALE_CHANNEL_INDEX\n} = NONPOSITION_CHANNEL_INDEX;\nexport const NONPOSITION_SCALE_CHANNELS = flagKeys(NONPOSITION_SCALE_CHANNEL_INDEX);\nexport type NonPositionScaleChannel = typeof NONPOSITION_SCALE_CHANNELS[0];\n\n// Declare SCALE_CHANNEL_INDEX\nconst SCALE_CHANNEL_INDEX = {\n  ...POSITION_SCALE_CHANNEL_INDEX,\n  ...NONPOSITION_SCALE_CHANNEL_INDEX\n};\n\n/** List of channels with scales */\nexport const SCALE_CHANNELS = flagKeys(SCALE_CHANNEL_INDEX);\nexport type ScaleChannel = typeof SCALE_CHANNELS[0];\n\nexport function isScaleChannel(channel: Channel): channel is ScaleChannel {\n  return !!SCALE_CHANNEL_INDEX[channel];\n}\n\nexport type SupportedMark = {\n  [mark in Mark]?: boolean\n};\n\n/**\n * Return whether a channel supports a particular mark type.\n * @param channel  channel name\n * @param mark the mark type\n * @return whether the mark supports the channel\n */\nexport function supportMark(channel: Channel, mark: Mark) {\n  return mark in getSupportedMark(channel);\n}\n\n/**\n * Return a dictionary showing whether a channel supports mark type.\n * @param channel\n * @return A dictionary mapping mark types to boolean values.\n */\nexport function getSupportedMark(channel: Channel): SupportedMark {\n  switch (channel) {\n    case COLOR:\n    case FILL:\n    case STROKE:\n\n    case DETAIL:\n    case KEY:\n    case TOOLTIP:\n    case HREF:\n    case ORDER:    // TODO: revise (order might not support rect, which is not stackable?)\n    case OPACITY:\n    case ROW:\n    case COLUMN:\n      return { // all marks\n        point: true, tick: true, rule: true, circle: true, square: true,\n        bar: true, rect: true, line: true, trail: true, area: true, text: true, geoshape: true\n      };\n    case X:\n    case Y:\n    case LATITUDE:\n    case LONGITUDE:\n      return { // all marks except geoshape. geoshape does not use X, Y -- it uses a projection\n        point: true, tick: true, rule: true, circle: true, square: true,\n        bar: true, rect: true, line: true, trail: true, area: true, text: true\n      };\n    case X2:\n    case Y2:\n    case LATITUDE2:\n    case LONGITUDE2:\n      return {\n        rule: true, bar: true, rect: true, area: true\n      };\n    case SIZE:\n      return {\n        point: true, tick: true, rule: true, circle: true, square: true,\n        bar: true, text: true, line: true, trail: true\n      };\n    case SHAPE:\n      return {point: true, geoshape: true};\n    case TEXT:\n      return {text: true};\n  }\n}\n\nexport function rangeType(channel: Channel): RangeType {\n  switch (channel) {\n    case X:\n    case Y:\n    case SIZE:\n    case OPACITY:\n    // X2 and Y2 use X and Y scales, so they similarly have continuous range.\n    case X2:\n    case Y2:\n      return 'continuous';\n\n    case ROW:\n    case COLUMN:\n    case SHAPE:\n    // TEXT, TOOLTIP, and HREF have no scale but have discrete output\n    case TEXT:\n    case TOOLTIP:\n    case HREF:\n      return 'discrete';\n\n    // Color can be either continuous or discrete, depending on scale type.\n    case COLOR:\n    case FILL:\n    case STROKE:\n      return 'flexible';\n\n    // No scale, no range type.\n\n    case LATITUDE:\n    case LONGITUDE:\n    case LATITUDE2:\n    case LONGITUDE2:\n    case DETAIL:\n    case KEY:\n    case ORDER:\n      return undefined;\n  }\n  /* istanbul ignore next: should never reach here. */\n  throw new Error('rangeType not implemented for ' + channel);\n}\n"]}},"error":null,"hash":"c338010aacf534c374c8c490926cb0cb","cacheData":{"env":{}}}